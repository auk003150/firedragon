<!DOCTYPE html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <title>å¤§å‘èˆç«é¾ AR éŠæˆ²</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />

  <!-- A-Frame èˆ‡ AR.js (aframe ç‰ˆæœ¬) -->
  <script src="https://aframe.io/releases/1.4.1/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar-nft.js"></script>

  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden; height: 100%; background: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'PingFang HK', 'PingFang SC', 'Microsoft JhengHei', Arial, sans-serif;
    }
    .hud { position: fixed; inset: 0; pointer-events: none; }
    .hud-top {
      display: flex; justify-content: space-between; align-items: center;
      padding: 8px 12px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      font-weight: 700; letter-spacing: 0.5px;
    }
    .badge {
      background: rgba(0,0,0,0.55); border: 1px solid rgba(255,255,255,0.2);
      border-radius: 10px; padding: 8px 12px; font-size: 16px; min-width: 110px; text-align: center;
    }
    .center-msg {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      color: #fff; background: rgba(0,0,0,0.55); border: 1px solid rgba(255,255,255,0.2);
      border-radius: 12px; padding: 12px 16px; font-size: 20px; text-align: center; pointer-events: none;
    }
    .controls {
      position: fixed; left: 50%; bottom: 10px; transform: translateX(-50%);
      display: flex; gap: 8px; pointer-events: auto;
    }
    .btn {
      background: rgba(0,0,0,0.65); color: #fff; border: 1px solid rgba(255,255,255,0.25);
      border-radius: 10px; padding: 8px 12px; font-weight: 600; cursor: pointer;
      transition: transform .1s ease, background .2s ease; user-select: none;
    }
    .btn:hover { background: rgba(255,255,255,0.12); }
    .btn:active { transform: scale(0.98); }
    .legend {
      position: fixed; right: 8px; bottom: 60px; color: #fff; font-size: 12px;
      background: rgba(0,0,0,0.55); border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px; padding: 8px 10px; line-height: 1.4; pointer-events: none; max-width: 50ch;
    }
  </style>
</head>
<body>
  <div id="bg" style="
      position: fixed; inset:0;
      background: url('image_1.png') center/cover no-repeat;
      opacity: 0.22; pointer-events:none; filter: saturate(1.05) contrast(1.05);
    "></div>

  <a-scene
    embedded
    renderer="colorManagement: true; physicallyCorrectLights: true; antialias: true"
    vr-mode-ui="enabled: false"
    arjs="sourceType: webcam; debugUIEnabled: false; patternRatio: 0.9;"
  >
    <a-entity light="type: ambient; intensity: 0.7; color: #ffffff"></a-entity>
    <a-entity light="type: directional; intensity: 0.85; color: #fff" position="1 1 0.5"></a-entity>

    <a-entity camera></a-entity>

    <a-marker type="hiro" id="hiroMarker">
      <a-entity id="bambooDragon" position="0 0 0" rotation="0 0 0">
        <a-sphere radius="0.18" color="#8B5A2B" position="0 0.12 0.0" scale="1 0.7 1"></a-sphere>
        <a-cylinder radius="0.005" height="0.14" color="#C19A6B" position="0.12 0.10 0.08" rotation="0 0 70"></a-cylinder>
        <a-cylinder radius="0.005" height="0.14" color="#C19A6B" position="0.12 0.10 -0.08" rotation="0 0 -70"></a-cylinder>

        <a-entity id="dragonBody" position="0 0 0"></a-entity>
        <a-entity id="sparks"></a-entity>
      </a-entity>
    </a-marker>

    <a-entity id="cardsRoot" position="0 0 0"></a-entity>

    <a-entity arjs-anchor></a-entity>
    <a-entity arjs-hit-test></a-entity>
  </a-scene>

  <div class="hud">
    <div class="hud-top">
      <div class="badge" id="scoreBadge">åˆ†æ•¸ï¼š0</div>
      <div class="badge" id="timeBadge">æ™‚é–“ï¼š60s</div>
    </div>
    <div class="center-msg" id="centerMsg">è«‹å…è¨±æ”åƒé ­æ¬Šé™ï¼Œæ‹¿è‘— hiro marker é–‹å§‹ï¼</div>
  </div>

  <div class="controls">
    <button class="btn" id="startBtn">é–‹å§‹éŠæˆ²</button>
    <button class="btn" id="resetBtn">é‡ç©</button>
  </div>

  <div class="legend">
    æ’æ“Šè¦å‰‡ï¼š<br/>
    æ–°å¹´å­—çœ¼ï¼ˆç¦ã€æ˜¥ã€è²¡ã€å®‰ã€æ—ºã€å‰ã€ç¥¥ã€è³€ã€é¾ã€å¹´ï¼‰+1 åˆ†<br/>
    ç„¡é—œåœ–æ¡ˆï¼ˆâš½ã€ğŸ”ã€ğŸ§ã€ğŸ§Šã€ğŸ§¼ã€ğŸºã€ğŸ’¡ã€ğŸ“ã€ğŸ§½ã€ğŸ§¯ï¼‰-1 åˆ†<br/>
    å€’æ•¸ 60 ç§’ï¼Œç›¡é‡åŠ åˆ†ï¼<br/>
    å°æç¤ºï¼šç§»å‹• hiro marker è¿½è¹¤ç«¹é¾ä¾†æ’ç‰Œå¡ã€‚
  </div>

  <script>
    // è£œä¸Šæœ¬åœ° clampï¼Œé¿å…ä¾è³´ AFRAME.utils.math.clamp
    const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

    // é…ç½®
    const GOOD_TEXTS = ['ç¦','æ˜¥','è²¡','å®‰','æ—º','å‰','ç¥¥','è³€','é¾','å¹´'];
    const BAD_TEXTS  = ['âš½','ğŸ”','ğŸ§','ğŸ§Š','ğŸ§¼','ğŸº','ğŸ’¡','ğŸ“','ğŸ§½','ğŸ§¯'];

    const GAME_DURATION = 60; // ç§’
    const CARD_COUNT_GOOD = 8;
    const CARD_COUNT_BAD = 8;
    const CARD_SPAWN_RADIUS = 1.2;
    const CARD_MIN_Y = 0.2, CARD_MAX_Y = 1.4;
    const CARD_SIZE = 0.22;
    const COLLIDE_DISTANCE = 0.22;

    let score = 0;
    let remaining = GAME_DURATION;
    let timerId = null;
    let running = false;

    const scoreBadge = document.getElementById('scoreBadge');
    const timeBadge = document.getElementById('timeBadge');
    const centerMsg = document.getElementById('centerMsg');
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');

    const scene = document.querySelector('a-scene');
    const cardsRoot = document.getElementById('cardsRoot');
    const hiro = document.getElementById('hiroMarker'); // åªå®£å‘Šä¸€æ¬¡
    const dragonBody = document.getElementById('dragonBody');
    const sparks = document.getElementById('sparks');

    function buildDragonBody() {
      while (dragonBody.firstChild) dragonBody.removeChild(dragonBody.firstChild);
      const count = 10;
      for (let i = 0; i < count; i++) {
        const seg = document.createElement('a-cylinder');
        seg.setAttribute('radius', 0.075 + (i===0?0.02:0));
        seg.setAttribute('height', 0.18);
        seg.setAttribute('color', i % 2 === 0 ? '#9C6B3D' : '#7D4F2A');
        seg.setAttribute('position', `${-0.2 - i*0.16} 0.10 0`);

        const rx = clamp(-10 + i*1.2, -15, 8);
        const ry = i * 2;
        const rz = (i % 3 === 0) ? 5 : -5;
        seg.setAttribute('rotation', `${rx} ${ry} ${rz}`);

        seg.setAttribute('segments-radial', 12);
        seg.setAttribute('segments-height', 1);
        dragonBody.appendChild(seg);

        if (i % 2 === 0) {
          const spike = document.createElement('a-cone');
          spike.setAttribute('radius-bottom', 0.01);
          spike.setAttribute('radius-top', 0.002);
          spike.setAttribute('height', 0.06);
          spike.setAttribute('color', '#C1440E');
          spike.setAttribute('position', `${-0.2 - i*0.16} 0.18 0.05`);
          spike.setAttribute('rotation', `-30 0 0`);
          dragonBody.appendChild(spike);
        }
      }

      while (sparks.firstChild) sparks.removeChild(sparks.firstChild);
      for (let s=0; s<20; s++){
        const p = document.createElement('a-sphere');
        p.setAttribute('radius', 0.006);
        p.setAttribute('color', '#FFCC66');
        p.setAttribute('position', `${-0.15 - Math.random()*0.6} ${0.18+Math.random()*0.1} ${(Math.random()-0.5)*0.15}`);
        p.setAttribute('animation', `property: position; dir: alternate; dur: ${500+Math.random()*600}; loop: true; to: ${-0.15 - Math.random()*0.6} ${0.22+Math.random()*0.12} ${(Math.random()-0.5)*0.2}`);
        sparks.appendChild(p);
      }
    }

    function createCard(label, isGood) {
      const card = document.createElement('a-entity');
      const plane = document.createElement('a-plane');
      const bgColor = isGood ? '#c62828' : '#37474f';
      const txtColor = '#fff';

      plane.setAttribute('width', CARD_SIZE);
      plane.setAttribute('height', CARD_SIZE);
      plane.setAttribute('color', bgColor);
      plane.setAttribute('material', `shader: flat; opacity: 0.95`);

      const text = document.createElement('a-text');
      text.setAttribute('value', label);
      text.setAttribute('color', txtColor);
      text.setAttribute('align', 'center');
      text.setAttribute('width', CARD_SIZE * 3.2);
      text.setAttribute('wrap-count', 4);
      text.setAttribute('position', '0 0 0.001');

      card.appendChild(plane);
      card.appendChild(text);

      const angle = Math.random() * Math.PI * 2;
      const radius = 0.4 + Math.random() * CARD_SPAWN_RADIUS;
      const x = Math.cos(angle) * radius;
      const z = Math.sin(angle) * radius - 0.6;
      const y = CARD_MIN_Y + Math.random() * (CARD_MAX_Y - CARD_MIN_Y);
      card.setAttribute('position', `${x} ${y} ${z}`);

      card.setAttribute('rotation', `0 ${Math.random()*360} 0`);

      const floatAmp = 0.08 + Math.random()*0.06;
      const floatDur = 2000 + Math.random()*1500;
      const rotDur = 2500 + Math.random()*2000;
      card.setAttribute('animation__float', `property: position; dir: alternate; dur: ${floatDur}; easing: easeInOutSine; loop: true; to: ${x} ${y+floatAmp} ${z}`);
      card.setAttribute('animation__rot', `property: rotation; dir: normal; dur: ${rotDur}; easing: linear; loop: true; to: 0 ${Math.random()<0.5?360:-360} 0`);

      card.setAttribute('class', isGood ? 'good-card' : 'bad-card');
      card.dataset.good = isGood ? '1' : '0';
      card.dataset.active = '1';

      return card;
    }

    function spawnCards() {
      while (cardsRoot.firstChild) cardsRoot.removeChild(cardsRoot.firstChild);

      const pick = (arr, n) => {
        const cp = arr.slice(); const out = [];
        for (let i=0; i<n && cp.length>0; i++) {
          out.push(cp.splice(Math.floor(Math.random()*cp.length),1)[0]);
        }
        return out;
      };
      const goodLabels = pick(GOOD_TEXTS, Math.min(CARD_COUNT_GOOD, GOOD_TEXTS.length));
      const badLabels = pick(BAD_TEXTS, Math.min(CARD_COUNT_BAD, BAD_TEXTS.length));

      goodLabels.forEach(label => cardsRoot.appendChild(createCard(label, true)));
      badLabels.forEach(label => cardsRoot.appendChild(createCard(label, false)));
    }

    function checkCollisions() {
      if (!running) return;
      const markerObj3D = hiro.object3D;
      if (!markerObj3D || !markerObj3D.visible) return;

      const markerWorldPos = new THREE.Vector3();
      markerObj3D.getWorldPosition(markerWorldPos);

      Array.from(cardsRoot.children).forEach(node => {
        if (!node.dataset || node.dataset.active !== '1') return;
        const obj = node.object3D;
        if (!obj) return;

        const cardWorldPos = new THREE.Vector3();
        obj.getWorldPosition(cardWorldPos);

        const dist = markerWorldPos.distanceTo(cardWorldPos);
        if (dist <= COLLIDE_DISTANCE) {
          const isGood = node.dataset.good === '1';
          score += isGood ? 1 : -1;
          updateScore();
          hitEffect(node, isGood);

          node.dataset.active = '0';
          node.setAttribute('animation__fade', 'property: components.material.material.opacity; to: 0; dur: 250; easing: easeOutQuad');
          setTimeout(() => {
            if (node.parentNode) node.parentNode.removeChild(node);
            maybeRespawn();
          }, 260);
        }
      });
    }

    function hitEffect(cardEntity, isGood) {
      const pos = new THREE.Vector3();
      cardEntity.object3D.getWorldPosition(pos);

      const fx = document.createElement('a-entity');
      fx.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
      for (let i=0; i<12; i++) {
        const p = document.createElement('a-sphere');
        p.setAttribute('radius', 0.01);
        p.setAttribute('color', isGood ? '#FFD54F' : '#90CAF9');
        p.setAttribute('position', '0 0 0');
        const angle = Math.random()*Math.PI*2;
        theR = 0.08 + Math.random()*0.08;
        const toX = Math.cos(angle)*theR;
        const toY = (Math.random()-0.3)*theR;
        const toZ = Math.sin(angle)*theR;
        p.setAttribute('animation__go', `property: position; to: ${toX} ${toY} ${toZ}; dur: 240; easing: easeOutQuad`);
        p.setAttribute('animation__fade', `property: components.material.material.opacity; to: 0; delay: 120; dur: 240`);
        fx.appendChild(p);
      }
      scene.appendChild(fx);
      setTimeout(()=>{ if (fx.parentNode) fx.parentNode.removeChild(fx); }, 520);
    }

    function maybeRespawn() {
      const activeCount = Array.from(cardsRoot.children).filter(n => n.dataset?.active === '1').length;
      const target = CARD_COUNT_GOOD + CARD_COUNT_BAD;
      if (activeCount < target) {
        const addGood = Math.random() < 0.5;
        const label = addGood
              ? GOOD_TEXTS[Math.floor(Math.random()*GOOD_TEXTS.length)]
              : BAD_TEXTS[Math.floor(Math.random()*BAD_TEXTS.length)];
        cardsRoot.appendChild(createCard(label, addGood));
      }
    }

    function updateScore() { scoreBadge.textContent = `åˆ†æ•¸ï¼š${score}`; }
    function updateTime() { timeBadge.textContent = `æ™‚é–“ï¼š${remaining}s`; }

    function startGame() {
      if (running) return;
      running = true;
      score = 0;
      remaining = GAME_DURATION;
      updateScore(); updateTime();
      centerMsg.textContent = 'éŠæˆ²é–‹å§‹ï¼ç§»å‹• hiro marker å»æ’ç‰Œå¡ï¼';
      spawnCards();

      if (timerId) clearInterval(timerId);
      timerId = setInterval(() => {
        remaining -= 1;
        updateTime();
        if (remaining <= 0) endGame();
      }, 1000);
    }

    function endGame() {
      running = false;
      if (timerId) { clearInterval(timerId); timerId = null; }
      centerMsg.textContent = `æ™‚é–“åˆ°ï¼æœ€çµ‚åˆ†æ•¸ï¼š${score}`;
      while (cardsRoot.firstChild) cardsRoot.removeChild(cardsRoot.firstChild);
    }

    function resetGame() {
      running = false;
      if (timerId) { clearInterval(timerId); timerId = null; }
      score = 0; remaining = GAME_DURATION;
      updateScore(); updateTime();
      centerMsg.textContent = 'å·²é‡ç½®ã€‚æŒ‰ã€Œé–‹å§‹éŠæˆ²ã€é‡æ–°é–‹å§‹ã€‚';
      while (cardsRoot.firstChild) cardsRoot.removeChild(cardsRoot.firstChild);
    }

    function tick() {
      checkCollisions();
      requestAnimationFrame(tick);
    }

    // ä½¿ç”¨åŒä¸€å€‹ hiro è®Šæ•¸æ›äº‹ä»¶
    hiro.addEventListener('markerFound', () => {
      if (!running) centerMsg.textContent = 'å·²åµæ¸¬åˆ° hiro markerï¼ŒæŒ‰ã€Œé–‹å§‹éŠæˆ²ã€ï¼';
    });
    hiro.addEventListener('markerLost', () => {
      if (running) centerMsg.textContent = 'Marker ä¸Ÿå¤±ï¼Œè«‹å°æº– hiroï¼';
      else centerMsg.textContent = 'æ‰¾ä¸åˆ° markerï¼Œè«‹å°‡ hiro marker å°æº–é¡é ­ã€‚';
    });

    startBtn.addEventListener('click', startGame);
    resetBtn.addEventListener('click', resetGame);

    buildDragonBody();
    requestAnimationFrame(tick);

    if (window.NodeList && !NodeList.prototype.forEach) {
      NodeList.prototype.forEach = Array.prototype.forEach;
    }
  </script>
</body>
</html>
