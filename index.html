<!DOCTYPE html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>å¤§å‘èˆç«é¾ AR å°éŠæˆ²</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; background: #000; color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans HK", "Noto Sans CJK", "PingFang HK", "Heiti TC", Arial, sans-serif;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      touch-action: manipulation;
    }
    .wrap { position: relative; width: 100%; height: 100%; background: #000; }
    video#cam {
      position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover;
      transform: none; background: #000;
    }
    img#bg { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; pointer-events: none; opacity: 1; mix-blend-mode: lighten; }
    canvas#game { position: absolute; inset: 0; width: 100%; height: 100%; touch-action: none; pointer-events: none; }

    /* é ‚éƒ¨ï¼šå…©è¡Œ */
    .ui {
      position: absolute; left: 0; right: 0; top: 0;
      display: grid; gap: 6px; padding: 10px 12px;
      background: linear-gradient(180deg, rgba(0,0,0,0.5), rgba(0,0,0,0));
      user-select: none; z-index: 20;
    }
    .topbar {
      display: flex; align-items: center; justify-content: space-between; gap: 8px;
      flex-wrap: nowrap;
    }
    .hudbar {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
    }

    .btn { background: #e11d48; border: none; color: #fff; border-radius: 10px; padding: 10px 14px; font-weight: 700; letter-spacing: 0.5px; box-shadow: 0 4px 12px rgba(225,29,72,0.35); }
    .btn.secondary { background:#334155; box-shadow: 0 4px 12px rgba(15,23,42,0.35); }
    .btn.ghost { background: rgba(0,0,0,0.45); border: 1px solid rgba(255,255,255,0.2); color: #fff; box-shadow: none; }
    .btn:disabled { opacity: 0.6; }
    .btn:active { transform: translateY(1px); }

    .hud { display: flex; gap: 10px; align-items: center; font-weight: 700; text-shadow: 0 2px 6px rgba(0,0,0,0.6); flex-wrap: wrap; }
    .chip { background: rgba(0,0,0,0.45); border: 1px solid rgba(255,255,255,0.2); border-radius: 999px; padding: 6px 10px; font-size: 14px; }

    /* åº•éƒ¨æç¤º */
    .hint {
      position: absolute; left: 0; right: 0; top: 50%; transform: translateY(-50%);
      text-align: center; padding: 0 16px; color: #ffd166; font-weight: 700; text-shadow: 0 2px 10px rgba(0,0,0,0.7); z-index: 5;
    }
    .ok { color: #22c55e; }
    .bad { color: #f97316; }

    /* é¢æ¿èˆ‡é®ç½© */
    .panel-backdrop {
      position: absolute; inset: 0; background: rgba(0,0,0,0.4); z-index: 30;
      opacity: 0; pointer-events: none; transition: opacity .2s ease;
    }
    .panel {
      position: absolute; top: 0; right: 0; height: 100%;
      background: rgba(17,24,39,0.9); backdrop-filter: blur(10px);
      border-left: 1px solid rgba(255,255,255,0.12);
      width: min(420px, 92vw);
      transform: translateX(100%);
      transition: transform .25s ease;
      z-index: 31; color: #fff; overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    .panel.open { transform: translateX(0); }
    .panel-backdrop.open { opacity: 1; pointer-events: auto; }

    .panel header {
      position: sticky; top: 0; background: rgba(17,24,39,0.95);
      padding: 12px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .panel h2 { margin: 0; font-size: 16px; }
    .panel .section { padding: 12px; display: grid; gap: 12px; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    .row .label { font-size: 14px; color: #e5e7eb; }
    .row .controls { display: flex; align-items: center; gap: 8px; }
    .mini { padding: 8px 10px; font-weight: 600; font-size: 12px; border-radius: 8px; background: rgba(0,0,0,0.45); border: 1px solid rgba(255,255,255,0.2); color: #fff; }
    .danger { background: #7f1d1d; border-color: rgba(255,255,255,0.25); }

    input[type="range"] { width: 160px; }
    .sliderRow { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; }
    .val { font-variant-numeric: tabular-nums; color: #fcd34d; min-width: 46px; text-align: right; font-weight: 700; }

    /* éš±è—åŸåº•éƒ¨ bar */
    .bar { display: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <video id="cam" playsinline autoplay muted></video>
    <img id="bg" alt="èƒŒæ™¯" src="image_1.png" />
    <canvas id="game"></canvas>

    <!-- é ‚éƒ¨ï¼šåˆ†å…©è¡Œ -->
    <div class="ui">
      <div class="topbar">
        <button id="startBtn" class="btn">é–‹å§‹</button>
        <button id="menuBtn" class="btn ghost menuBtn">â‰¡ é¸å–®</button>
      </div>
      <div class="hudbar">
        <div class="hud">
          <div class="chip">åˆ†æ•¸ï¼š<span id="score">0</span></div>
          <div class="chip">Comboï¼š<span id="combo">0</span></div>
          <div class="chip">æ™‚é–“ï¼š<span id="time">60</span>s</div>
        </div>
      </div>
    </div>

    <!-- é¢æ¿èˆ‡é®ç½© -->
    <div id="panelBackdrop" class="panel-backdrop"></div>
    <aside id="panel" class="panel" aria-hidden="true">
      <header>
        <h2>è¨­å®š</h2>
        <button id="closePanel" class="btn ghost" aria-label="é—œé–‰">âœ•</button>
      </header>
      <div class="section">
        <div class="row">
          <div class="label">é¡é ­</div>
          <div class="controls">
            <button id="toggleFacing" class="mini">åˆ‡æ›é¡é ­</button>
          </div>
        </div>
        <div class="row">
          <div class="label">é¡åƒ</div>
          <div class="controls">
            <button id="toggleMirror" class="mini">é¡åƒï¼šé—œ</button>
          </div>
        </div>
        <div class="row">
          <div class="label">è¢å¹•</div>
          <div class="controls">
            <button id="fullscreenBtn" class="mini">å…¨å±</button>
          </div>
        </div>
        <div class="row">
          <div class="label">éŠæˆ²</div>
          <div class="controls">
            <button id="resetBtn" class="mini danger">é‡ç½®</button>
          </div>
        </div>
      </div>

      <div class="section" style="border-top:1px solid rgba(255,255,255,0.1)">
        <div class="sliderRow">
          <div class="label">Hmin</div>
          <div class="controls">
            <input id="hMin" type="range" min="0" max="360" value="330">
            <span id="hMinVal" class="val">330</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">Hmax</div>
          <div class="controls">
            <input id="hMax" type="range" min="0" max="360" value="20">
            <span id="hMaxVal" class="val">20</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">Smin</div>
          <div class="controls">
            <input id="sMin" type="range" min="0" max="100" value="50">
            <span id="sMinVal" class="val">50</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">Vmin</div>
          <div class="controls">
            <input id="vMin" type="range" min="0" max="100" value="40">
            <span id="vMinVal" class="val">40</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">éˆæ•åº¦</div>
          <div class="controls">
            <input id="sens" type="range" min="0" max="300" value="80">
            <span id="sensVal" class="val">80</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">ç›®æ¨™å¯†åº¦</div>
          <div class="controls">
            <input id="density" type="range" min="1" max="10" value="4">
            <span id="densityVal" class="val">4</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">é€Ÿåº¦</div>
          <div class="controls">
            <input id="speed" type="range" min="1" max="10" value="5">
            <span id="speedVal" class="val">5</span>
          </div>
        </div>
      </div>

      <!-- æ–°å¢ï¼šHiro åµæ¸¬éˆæ•åº¦è¨­å®š -->
      <div class="section" style="border-top:1px solid rgba(255,255,255,0.1)">
        <div class="row" style="justify-content:flex-start; color:#cbd5e1; font-size:13px;">
          åµæ¸¬éæ–¼éˆæ•æ™‚ï¼Œå¯æé«˜é¢ç©/å‘¨é•·/æ–¹å½¢åš´æ ¼åº¦ï¼Œæˆ–å¢å¤§å€å¡Šå¤§å°/åç§»ã€‚
        </div>
        <div class="sliderRow">
          <div class="label">æœ€å°é¢ç© (â€°)</div>
          <div class="controls">
            <input id="areaPpm" type="range" min="1" max="15" value="3">
            <span id="areaPpmVal" class="val">3â€°</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">æœ€å°é‚Šé•· (px)</div>
          <div class="controls">
            <input id="minSide" type="range" min="8" max="80" value="26">
            <span id="minSideVal" class="val">26</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">é‚Šé•·æ¯”ä¾‹ä¸Šé™</div>
          <div class="controls">
            <input id="ratioTol" type="range" min="110" max="140" step="1" value="118">
            <span id="ratioTolVal" class="val">1.18Ã—</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">è§’åº¦å®¹å·® (cos)</div>
          <div class="controls">
            <input id="angleCos" type="range" min="5" max="35" step="1" value="22">
            <span id="angleCosVal" class="val">0.22</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">æœ€å°å‘¨é•· (px)</div>
          <div class="controls">
            <input id="minPeri" type="range" min="40" max="200" value="80">
            <span id="minPeriVal" class="val">80</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">å€å¡Šå¤§å° S</div>
          <div class="controls">
            <input id="thrBlock" type="range" min="9" max="39" step="2" value="19">
            <span id="thrBlockVal" class="val">19</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">å°æ¯”åç§» T</div>
          <div class="controls">
            <input id="thrOffset" type="range" min="2" max="30" value="8">
            <span id="thrOffsetVal" class="val">8</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">é€£çºŒæ‰¾åˆ°å¹€</div>
          <div class="controls">
            <input id="foundFrames" type="range" min="1" max="8" value="3">
            <span id="foundFramesVal" class="val">3</span>
          </div>
        </div>
        <div class="sliderRow">
          <div class="label">é€£çºŒéºå¤±å¹€</div>
          <div class="controls">
            <input id="lostFrames" type="range" min="2" max="15" value="8">
            <span id="lostFramesVal" class="val">8</span>
          </div>
        </div>
      </div>
    </aside>

    <div id="hint" class="hint">æŒ‰ã€Œé–‹å§‹ã€å…è¨±ç›¸æ©Ÿæ¬Šé™ã€‚è«‹å°‡ Hiro æ¨™è¨˜å±•ç¤ºåœ¨é¡é ­å‰ã€‚</div>
  </div>

  <!-- js-arucoï¼ˆå«å¯èª¿é–¾å€¼ï¼‰ -->
  <script>
    /*
     * js-aruco (ç²¾ç°¡ç‰ˆï¼Œé™„åŠ ï¼š
     * - 3x3 box blur
     * - å¯èª¿ Adaptive Threshold (S, T)
     * - åŠ å¼·å¹¾ä½•éæ¿¾ä»¥æ¸›å°‘èª¤æª¢
     */
    /*! js-aruco embedded */
    (function(global){
      var CV = {
        grayscale: function(imageSrc){
          var src=imageSrc.data, dst=new Uint8Array(imageSrc.width*imageSrc.height);
          for(var i=0,j=0;i<src.length;i+=4,++j){
            dst[j]=(src[i]*0.299 + src[i+1]*0.587 + src[i+2]*0.114)|0;
          }
          return {width:imageSrc.width,height:imageSrc.height,data:dst};
        },
        boxBlur3: function(imageGray){
          var w=imageGray.width, h=imageGray.height, src=imageGray.data;
          var dst=new Uint8Array(src.length);
          for(var y=0;y<h;y++){
            var ym1 = y>0? y-1 : y, yp1 = y<h-1? y+1 : y;
            for(var x=0;x<w;x++){
              var xm1 = x>0? x-1 : x, xp1 = x<w-1? x+1 : x;
              var sum = src[ym1*w + xm1] + src[ym1*w + x] + src[ym1*w + xp1]
                      + src[y*w   + xm1] + src[y*w   + x] + src[y*w   + xp1]
                      + src[yp1*w + xm1] + src[yp1*w + x] + src[yp1*w + xp1];
              dst[y*w + x] = (sum/9)|0;
            }
          }
          return {width:w,height:h,data:dst};
        },
        integralImage: function(imageSrc){
          var w=imageSrc.width,h=imageSrc.height, src=imageSrc.data, sum=new Int32Array(w*h);
          for(var y=0;y<h;++y){
            var row=y*w, rowsum=0;
            for(var x=0;x<w;++x){
              rowsum += src[row+x];
              sum[row+x] = rowsum + (y>0?sum[row-w+x]:0);
            }
          }
          return {width:w,height:h,data:sum};
        },
        adaptiveThreshold: function(imageSrc, S, T){
          var ii=this.integralImage(imageSrc), w=imageSrc.width, h=imageSrc.height, src=imageSrc.data, dst=new Uint8Array(src.length);
          var s2=S>>1;
          for(var y=0;y<h;++y){
            var y0=Math.max(y-s2,0), y1=Math.min(y+s2,h-1);
            for(var x=0;x<w;++x){
              var x0=Math.max(x-s2,0), x1=Math.min(x+s2,w-1);
              var count=(x1-x0+1)*(y1-y0+1);
              var sum=ii.data[y1*w+x1] - (y0>0?ii.data[(y0-1)*w+x1]:0) - (x0>0?ii.data[y1*w+x0-1]:0) + (x0>0&&y0>0?ii.data[(y0-1)*w+x0-1]:0);
              dst[y*w+x] = src[y*w+x]*count <= sum*(100-T)/100 ? 0:255;
            }
          }
          return {width:w,height:h,data:dst};
        },
        findContours: function(imageSrc){
          var labels=new Int32Array(imageSrc.data.length), label=1, comps=[];
          var w=imageSrc.width, h=imageSrc.height, data=imageSrc.data;
          function bfs(seed){
            var q=[seed], idx, minx=w, miny=h, maxx=0, maxy=0, pts=[];
            labels[seed]=label;
            while(q.length){
              idx=q.pop();
              var x=idx%w, y=idx/w|0;
              pts.push({x:x,y:y});
              if(x<minx)minx=x; if(x>maxx)maxx=x; if(y<miny)miny=y; if(y>maxy)maxy=y;
              var n=[idx-1,idx+1,idx-w,idx+w];
              for(var k=0;k<4;++k){
                var ni=n[k];
                if(ni<0||ni>=data.length) continue;
                if(labels[ni]||data[ni]) continue;
                labels[ni]=label; q.push(ni);
              }
            }
            comps.push({points:pts, minx,miny,maxx,maxy});
          }
          for(var i=0;i<data.length;++i){
            if(data[i]===0 && labels[i]===0){ bfs(i); label++; }
          }
          var contours=[];
          for(var c of comps){
            var rect=[{x:c.minx,y:c.miny},{x:c.maxx,y:c.miny},{x:c.maxx,y:c.maxy},{x:c.minx,y:c.maxy}];
            contours.push(rect);
          }
          return contours;
        },
        perimeter: function(poly){
          var p=0;
          for(var i=0;i<poly.length;++i){
            var a=poly[i], b=poly[(i+1)%poly.length];
            var dx=a.x-b.x, dy=a.y-b.y;
            p+=Math.hypot(dx,dy);
          }
          return p;
        },
        approxPolyDP: function(curve, epsilon){
          return curve;
        }
      };

      var AR = {};
      AR.Marker = function(id,corners){ this.id=id; this.corners=corners; };
      AR.Dictionary = {
        markers:{
          0: [
            1,1,1,1,1,
            1,0,0,0,1,
            1,0,1,0,1,
            1,0,0,0,1,
            1,1,1,1,1
          ]
        },
        match: function(code){ return 0; }
      };

      AR.Detector = function(){};
      AR.Detector.prototype.detect = function(imageData, cfg){
        cfg = cfg || {};
        var S = cfg.blockSize || 19;
        var T = cfg.offset   || 8;
        var minArea    = cfg.minArea || 0;
        var minSide    = cfg.minSide || 0;
        var ratioTol   = cfg.ratioTol || 1.25;
        var angleCosTol= cfg.angleCos || 0.3;
        var minPeri    = cfg.minPeri || 60;

        var gray = CV.grayscale(imageData);
        var smooth = CV.boxBlur3(gray);
        var bin = CV.adaptiveThreshold(smooth, S, T);
        var contours = CV.findContours(bin);
        var markers=[];
        for(var c of contours){
          // é‚Šé•·èˆ‡æ¯”ä¾‹
          var l01 = Math.hypot(c[0].x - c[1].x, c[0].y - c[1].y);
          var l12 = Math.hypot(c[1].x - c[2].x, c[1].y - c[2].y);
          var l23 = Math.hypot(c[2].x - c[3].x, c[2].y - c[3].y);
          var l30 = Math.hypot(c[3].x - c[0].x, c[3].y - c[0].y);
          var minL = Math.min(l01,l12,l23,l30);
          var maxL = Math.max(l01,l12,l23,l30);
          if (minL < minSide) continue;
          if (maxL / minL > ratioTol) continue;

          var peri = l01+l12+l23+l30;
          if (peri < minPeri) continue;

          // è§’åº¦æ¥è¿‘ 90 åº¦
          function cosAt(i){
            var p0 = c[(i+3)%4], p1 = c[i], p2 = c[(i+1)%4];
            var v1x = p0.x - p1.x, v1y = p0.y - p1.y;
            var v2x = p2.x - p1.x, v2y = p2.y - p1.y;
            var dot = v1x*v2x + v1y*v2y;
            var n1 = Math.hypot(v1x,v1y), n2=Math.hypot(v2x,v2y);
            if (n1===0||n2===0) return 1;
            return dot/(n1*n2);
          }
          var maxCos = Math.max(Math.abs(cosAt(0)), Math.abs(cosAt(1)), Math.abs(cosAt(2)), Math.abs(cosAt(3)));
          if (maxCos > angleCosTol) continue;

          // é¢ç©
          var area = 0;
          for (let i=0;i<4;i++){
            var a=c[i], b=c[(i+1)%4];
            area += a.x*b.y - b.x*a.y;
          }
          area = Math.abs(area)*0.5;
          if (area < minArea) continue;

          markers.push(new AR.Marker(0, c));
        }
        return markers;
      };

      global.CV = CV;
      global.AR = AR;
    })(window);
  </script>

  <script>
    // ========= DOM =========
    const video = document.getElementById('cam');
    const bgImg = document.getElementById('bg');
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: true });

    const startBtn = document.getElementById('startBtn');

    // é¢æ¿ DOM
    const menuBtn = document.getElementById('menuBtn');
    const panel = document.getElementById('panel');
    const panelBackdrop = document.getElementById('panelBackdrop');
    const closePanelBtn = document.getElementById('closePanel');

    const resetBtn = document.getElementById('resetBtn');
    const toggleFacingBtn = document.getElementById('toggleFacing');
    const toggleMirrorBtn = document.getElementById('toggleMirror');
    const fullscreenBtn = document.getElementById('fullscreenBtn');

    const scoreEl = document.getElementById('score');
    const comboEl = document.getElementById('combo');
    const timeEl = document.getElementById('time');
    const hintEl = document.getElementById('hint');

    // æ»‘æ¡¿èˆ‡æ•¸å€¼
    const hMinEl = document.getElementById('hMin');
    const hMaxEl = document.getElementById('hMax');
    const sMinEl = document.getElementById('sMin');
    const vMinEl = document.getElementById('vMin');
    const sensEl = document.getElementById('sens');
    const densEl = document.getElementById('density');
    const speedEl = document.getElementById('speed');
    const hMinVal = document.getElementById('hMinVal');
    const hMaxVal = document.getElementById('hMaxVal');
    const sMinVal = document.getElementById('sMinVal');
    const vMinVal = document.getElementById('vMinVal');
    const sensVal = document.getElementById('sensVal');
    const densityVal = document.getElementById('densityVal');
    const speedVal = document.getElementById('speedVal');

    // æ–°å¢ï¼šåµæ¸¬é–¾å€¼æ»‘æ¡¿
    const areaPpmEl = document.getElementById('areaPpm');
    const minSideEl = document.getElementById('minSide');
    const ratioTolEl = document.getElementById('ratioTol');
    const angleCosEl = document.getElementById('angleCos');
    const minPeriEl = document.getElementById('minPeri');
    const thrBlockEl = document.getElementById('thrBlock');
    const thrOffsetEl = document.getElementById('thrOffset');
    const foundFramesEl = document.getElementById('foundFrames');
    const lostFramesEl = document.getElementById('lostFrames');
    const areaPpmVal = document.getElementById('areaPpmVal');
    const minSideVal = document.getElementById('minSideVal');
    const ratioTolVal = document.getElementById('ratioTolVal');
    const angleCosVal = document.getElementById('angleCosVal');
    const minPeriVal = document.getElementById('minPeriVal');
    const thrBlockVal = document.getElementById('thrBlockVal');
    const thrOffsetVal = document.getElementById('thrOffsetVal');
    const foundFramesVal = document.getElementById('foundFramesVal');
    const lostFramesVal = document.getElementById('lostFramesVal');

    // ========= ç‹€æ…‹ =========
    let running = false;
    let gameOver = false;
    let W = 0, H = 0, dpr = 1;

    let score = 0, combo = 0, timeLeft = 60;
    let timerId = null;

    let centroid = { x: 0, y: 0 };
    let direction = { x: 1, y: 0 };
    const smoothing = 0.22; // æ›´å¹³æ»‘

    let useEnvironment = true;
    let mirrored = false;

    // åµæ¸¬ç¯€æµ
    const detectInterval = 55; // ms
    let lastDetectTime = 0;
    let lastMarkerResult = null;
    let consecutiveFound = 0;
    let consecutiveLost = 0;
    let detected = false;
    let lastHintState = 'idle';

    // åµæ¸¬é…ç½®ï¼ˆå¯èª¿ï¼‰
    const detectCfg = {
      areaPpm: 3,       // â€° of scaled frame
      minSide: 26,      // px
      ratioTol: 1.18,   // max longest/shortest side
      angleCos: 0.22,   // |cos(theta)| tolerance to 90Â°
      minPeri: 80,      // px
      blockSize: 19,    // adaptive threshold S (odd)
      offset: 8,        // adaptive threshold T
      foundFrames: 3,   // frames to confirm found
      lostFrames: 8     // frames to confirm lost
    };

    // ========= å–®å¼µè²¼åœ–ï¼ˆç„¡æ—‹è½‰ï¼‰=========
    const dragonImg = new Image();
    dragonImg.src = 'image_2.png';
    let dragonImgReady = false;
    dragonImg.onload = () => { dragonImgReady = true; };

    const sprite = {
      drawWidth: 90,
      drawHeight: 90,
      headAnchorX: 0.6,
      headAnchorY: 0.6,
      fineOffsetX: 0,
      fineOffsetY: -0.1
    };

    // æ–‡å­—ç›®æ¨™
    const goodList = ['ç¦', 'æ˜¥', 'è²¡', 'å®‰', 'æ—º', 'å‰', 'ç¥¥', 'è³€', 'é¾', 'å¹´'];
    const badList  = ['âš½', 'ğŸ”', 'ğŸ§', 'ğŸ§Š', 'ğŸ§¼', 'ğŸº', 'ğŸ’¡', 'ğŸ“', 'ğŸ§½', 'ğŸ§¯'];
    const items = [];
    const MAX_ITEMS = 14;

    // ç²’å­
    const particles = [];
    const MAX_PARTICLES = 1200;

    // ========= ç•«å¸ƒå¤§å° =========
    let resizeTimer = null;
    function resize() {
      const doResize = () => {
        dpr = Math.min(window.devicePixelRatio || 1, 2);
        const rect = canvas.getBoundingClientRect();
        W = rect.width; H = rect.height;
        canvas.width = Math.round(W * dpr);
        canvas.height = Math.round(H * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      };
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(doResize, 50);
    }
    window.addEventListener('resize', resize, { passive: true });
    window.addEventListener('orientationchange', () => setTimeout(resize, 150), { passive: true });
    resize();

    // ========= èƒ½åŠ›æª¢æŸ¥ =========
    function supported() {
      const ok = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
      if (!ok) {
        hintEl.textContent = 'æ­¤è£ç½®æˆ–ç€è¦½å™¨ä¸æ”¯æ´ç›¸æ©Ÿã€‚è«‹ä½¿ç”¨æœ€æ–°ç‰ˆ Chrome / Safari ä¸¦ç¢ºä¿ HTTPSã€‚';
        hintEl.className = 'hint bad';
      }
      if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        hintEl.textContent = 'è«‹ä½¿ç”¨ HTTPS ç¶²ç«™ä»¥é–‹å•Ÿç›¸æ©Ÿæ¬Šé™ã€‚';
        hintEl.className = 'hint bad';
      }
      return ok;
    }

    // ========= ç›¸æ©Ÿ =========
    let currentStream = null;
    async function stopStream() {
      if (currentStream) {
        currentStream.getTracks().forEach(t => t.stop());
        currentStream = null;
      }
    }
    async function initCamera() {
      const kinds = [
        { width: { ideal: 1280 }, height: { ideal: 720 } },
        { width: { ideal: 960 }, height: { ideal: 540 } },
        { width: { ideal: 640 }, height: { ideal: 480 } }
      ];
      const facing = useEnvironment ? { ideal: 'environment' } : { ideal: 'user' };
      let lastErr = null;
      await stopStream();
      for (const res of kinds) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: false,
            video: { ...res, facingMode: facing }
          });
          currentStream = stream;
          video.srcObject = stream;
          video.playsInline = true;
          await video.play().catch(()=>{});
          applyMirror();
          return true;
        } catch (err) { lastErr = err; }
      }
      console.error('Camera init failed:', lastErr);
      hintEl.textContent = 'ç›¸æ©Ÿç„¡æ³•å•Ÿå‹•ï¼Œè«‹æª¢æŸ¥æ¬Šé™/ç€è¦½å™¨è¨­å®šæˆ–æ”¹ç”¨å…¶ä»–è£ç½®ã€‚';
      hintEl.className = 'hint bad';
      return false;
    }

    function applyMirror() {
      video.style.transform = mirrored ? 'scaleX(-1)' : 'none';
      toggleMirrorBtn.textContent = `é¡åƒï¼š${mirrored ? 'é–‹' : 'é—œ'}`;
    }

    // ========= Hiro æ¨™è¨˜åµæ¸¬ =========
    const workCanvas = document.createElement('canvas');
    const wctx = workCanvas.getContext('2d', { willReadFrequently: true });
    const detector = new AR.Detector();

    function markerArea(marker){
      const cs = marker.corners;
      let area = 0;
      for (let i=0;i<cs.length;i++){
        const c0 = cs[i], c1 = cs[(i+1)%cs.length];
        area += c0.x * c1.y - c1.x * c0.y;
      }
      return Math.abs(area) * 0.5;
    }

    function trackHiroMarker(now = performance.now()) {
      if (now - lastDetectTime < detectInterval) return lastMarkerResult;
      lastDetectTime = now;

      const vw = video.videoWidth|0, vh = video.videoHeight|0;
      if (vw === 0 || vh === 0) return lastMarkerResult = null;

      const scale = 0.7;
      const w = Math.min(640, Math.max(48, Math.round(vw * scale)));
      const h = Math.min(640, Math.max(48, Math.round(vh * scale)));
      workCanvas.width = w; workCanvas.height = h;

      try {
        wctx.drawImage(video, 0, 0, w, h);
      } catch (e) {
        return lastMarkerResult = null;
      }

      const imageData = wctx.getImageData(0, 0, w, h);

      // è¨ˆç®—ç•¶å‰æœ€å°é¢ç©ï¼ˆä¾è¢å¹•æ¯”ä¾‹ï¼‰
      const minAreaAbs = w * h * (detectCfg.areaPpm / 1000);

      const markers = detector.detect(imageData, {
        blockSize: detectCfg.blockSize,
        offset: detectCfg.offset,
        minArea: minAreaAbs,
        minSide: detectCfg.minSide,
        ratioTol: detectCfg.ratioTol,
        angleCos: detectCfg.angleCos,
        minPeri: detectCfg.minPeri
      });

      if (!markers || markers.length === 0) return lastMarkerResult = null;

      // é¸æœ€å¤§é¢ç©
      let best = null, bestArea = 0;
      for (let i=0;i<markers.length;i++){
        const a = markerArea(markers[i]);
        if (a > bestArea) { bestArea = a; best = markers[i]; }
      }
      if (!best || bestArea < minAreaAbs) return lastMarkerResult = null;

      const corners = best.corners;
      let cx = 0, cy = 0;
      for (const c of corners){ cx += c.x; cy += c.y; }
      cx /= corners.length; cy /= corners.length;

      const canvasX = (cx / w) * W;
      const canvasY = (cy / h) * H;
      const finalX = mirrored ? (W - canvasX) : canvasX;

      return lastMarkerResult = { x: finalX, y: canvasY, area: bestArea };
    }

    // ========= ç›®æ¨™ç‰©ä»¶ =========
    function spawnItem() {
      const isGood = Math.random() < 0.6;
      const text = isGood ? goodList[Math.floor(Math.random()*goodList.length)] : badList[Math.floor(Math.random()*badList.length)];
      const size = 28 + Math.random()*18;
      const margin = 28 + size;
      const x = margin + Math.random()*(W - margin*2);
      const y = 80 + Math.random()*(H - 160);
      const speed = parseInt(speedEl.value, 10);
      const vx = (Math.random()-0.5)*speed;
      const vy = (Math.random()-0.5)*speed;
      const ttl = 12 + Math.random()*10;
      items.push({ x,y,vx,vy,text,size,isGood,ttl });
    }
    function ensureItems() {
      const target = parseInt(densEl.value, 10) * 3;
      while (items.length < Math.min(MAX_ITEMS, target)) spawnItem();
    }
    function updateItems(dt) {
      for (let i=items.length-1; i>=0; i--){
        const it=items[i];
        it.x += it.vx; it.y += it.vy; it.ttl -= dt;
        if (it.x<20 || it.x>W-20) it.vx*=-1;
        if (it.y<60 || it.y>H-60) it.vy*=-1;
        if (it.ttl<=0) items.splice(i,1);
      }
      ensureItems();
    }
    function drawItems(ctx) {
      for (const it of items){
        ctx.save();
        ctx.font = `700 ${it.size}px system-ui, "Noto Color Emoji", "Apple Color Emoji"`;
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.shadowColor = it.isGood ? 'rgba(255,215,0,0.9)' : 'rgba(255,90,0,0.7)';
        ctx.shadowBlur = 12;
        ctx.fillStyle = it.isGood ? '#ffd166' : '#ff6b6b';
        ctx.fillText(it.text, it.x, it.y);
        ctx.restore();
      }
    }

    // ========= ç²’å­æ•ˆæœ =========
    function spawnIncenseParticles(pos, dir, count=6) {
      for (let i=0; i<count; i++){
        if (particles.length >= MAX_PARTICLES) break;
        const angle = Math.atan2(dir.y, dir.x) + (Math.random()*0.8 - 0.4);
        const speed = 40 + Math.random()*120;
        const vx = Math.cos(angle)*speed;
        const vy = Math.sin(angle)*speed - Math.random()*20;
        particles.push({
          x: pos.x + (Math.random()*6-3),
          y: pos.y + (Math.random()*6-3),
          vx, vy,
          life: 0.45 + Math.random()*0.35,
          age: 0,
          size: 2 + Math.random()*2.5,
          hue: 20 + Math.random()*20
        });
      }
    }
    function updateParticles(dt) {
      for (let i=particles.length-1; i>=0; i--){
        const p = particles[i];
        p.age += dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 20 * dt;
        if (p.age >= p.life) particles.splice(i,1);
      }
    }
    function drawParticles(ctx) {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const p of particles){
        const t = p.age / p.life;
        const alpha = 1 - t;
        const size = p.size * (0.8 + 0.4*(1-t));
        const col = `hsla(${p.hue}, 90%, ${60 - t*30}%, ${alpha})`;
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.arc(p.x, p.y, size, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    // ========= å–®å¼µè²¼åœ–ç¹ªè£½ï¼ˆç„¡æ—‹è½‰ï¼‰=========
    function drawDragon(ctx, head) {
      if (!dragonImgReady) return;

      const imgW = sprite.drawWidth;
      const imgH = sprite.drawHeight;

      ctx.save();
      ctx.translate(head.x, head.y);

      const headOffsetX = -imgW * sprite.headAnchorX + (sprite.fineOffsetX || 0);
      const headOffsetY = -imgH * sprite.headAnchorY + (sprite.fineOffsetY ? sprite.fineOffsetY * imgH : 0);
      ctx.translate(headOffsetX, headOffsetY);

      ctx.drawImage(dragonImg, 0, -imgH * 0.5, imgW, imgH);

      spawnIncenseParticles({ x: 0, y: 0 }, { x: 1, y: 0 }, 8);
      ctx.restore();
    }

    // ========= ç¢°æ’èˆ‡å¾—åˆ† =========
    function circleHit(ax, ay, bx, by, r) {
      const dx = ax - bx, dy = ay - by;
      return (dx*dx + dy*dy) <= r*r;
    }
    function handleCollisions(head) {
      for (let i=items.length-1; i>=0; i--){
        const it=items[i];
        const radius = Math.max(24, sprite.drawHeight * 0.35);
        if (circleHit(head.x, head.y, it.x, it.y, radius)){
          if (it.isGood){
            combo++;
            const bonus = 10 + Math.min(60, combo*2);
            score += bonus;
            flash('+ ' + bonus, it.x, it.y, true);
          } else {
            combo = 0;
            score = Math.max(0, score - 15);
            flash('âˆ’ 15', it.x, it.y, false);
          }
          items.splice(i,1);
          scoreEl.textContent = score;
          comboEl.textContent = combo;
        }
      }
    }

    const floatTexts = [];
    function flash(text, x, y, ok) { floatTexts.push({ text, x, y, ok, t: 0 }); }
    function drawFloatTexts(dt) {
      for (let i=floatTexts.length-1; i>=0; i--){
        const f=floatTexts[i]; f.t += dt;
        const alpha = Math.max(0, 1 - f.t/1.2);
        const dy = -f.t*40;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font = '800 22px system-ui';
        ctx.textAlign = 'center'; ctx.textBaseline='middle';
        ctx.fillStyle = f.ok ? '#22c55e' : '#f97316';
        ctx.fillText(f.text, f.x, f.y + dy);
        ctx.restore();
        if (alpha <= 0.01) floatTexts.splice(i,1);
      }
    }

    // ========= ä¸»å¾ªç’° =========
    let lastTime = performance.now();
    function updateHint(state) {
      if (state === lastHintState) return;
      lastHintState = state;
      if (state === 'found') {
        hintEl.textContent = 'å·²åµæ¸¬åˆ° Hiro æ¨™è¨˜ï¼Œè«‹ä¿æŒæ¨™è¨˜å¹³æ•´ã€ç½®ä¸­ä¸”å…‰ç·šå‡å‹»ã€‚';
        hintEl.className = 'hint ok';
      } else if (state === 'search') {
        hintEl.textContent = 'æœªåµæ¸¬åˆ° Hiro æ¨™è¨˜ï¼Œè«‹å°‡æ¨™è¨˜ç½®ä¸­ã€è·é›¢ 20â€“60cmï¼Œä¸¦ç¢ºä¿å…‰ç·šå……è¶³ã€‚';
        hintEl.className = 'hint bad';
      } else {
        hintEl.textContent = 'æŒ‰ã€Œé–‹å§‹ã€å…è¨±ç›¸æ©Ÿæ¬Šé™ã€‚è«‹å°‡ Hiro æ¨™è¨˜å±•ç¤ºåœ¨é¡é ­å‰ã€‚';
        hintEl.className = 'hint';
      }
    }

    function tick(now) {
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;

      ctx.clearRect(0, 0, W, H);

      const raw = trackHiroMarker(now);
      if (raw) {
        consecutiveFound++;
        consecutiveLost = 0;
        if (!detected && consecutiveFound >= detectCfg.foundFrames) {
          detected = true;
          updateHint('found');
        }
        if (detected) {
          centroid.x = centroid.x ? (centroid.x + (raw.x - centroid.x) * smoothing) : raw.x;
          centroid.y = centroid.y ? (centroid.y + (raw.y - centroid.y) * smoothing) : raw.y;
        }
      } else {
        consecutiveFound = 0;
        consecutiveLost++;
        if (detected && consecutiveLost >= detectCfg.lostFrames) {
          detected = false;
          updateHint('search');
        }
        // çŸ­æš«éºå¤±æ™‚ä¿ç•™æœ€å¾Œä½ç½®
      }

      updateItems(dt);
      drawItems(ctx);

      const head = { x: centroid.x || W/2, y: centroid.y || H/2 };
      drawDragon(ctx, head);

      updateParticles(dt);
      drawParticles(ctx);

      handleCollisions(head);
      drawFloatTexts(dt);

      if (running && !gameOver) requestAnimationFrame(tick);
    }

    // ========= æ§åˆ¶ =========
    function startGameLoop() {
      if (running) return;
      running = true; gameOver = false;
      lastTime = performance.now();
      ensureItems();
      clearInterval(timerId);
      timeLeft = 60;
      timeEl.textContent = timeLeft;
      timerId = setInterval(() => {
        timeLeft--; timeEl.textContent = timeLeft;
        if (timeLeft <= 0) {
          clearInterval(timerId);
          running = false; gameOver = true;
          hintEl.textContent = `æ™‚é–“åˆ°ï¼ç¸½åˆ†ï¼š${score}`;
          hintEl.className = 'hint';
          startBtn.disabled = false;
        }
      }, 1000);
      requestAnimationFrame(tick);
    }

    async function startAll() {
      if (!supported()) return;
      startBtn.disabled = true;
      try {
        const ok = await initCamera();
        if (ok) {
          updateHint('search');
          startGameLoop();
        } else {
          startBtn.disabled = false;
        }
      } catch (err) {
        console.error(err);
        hintEl.textContent = 'ç›¸æ©Ÿç„¡æ³•å•Ÿå‹•ï¼Œè«‹ç¢ºèªæ¬Šé™èˆ‡ HTTPSã€‚';
        hintEl.className = 'hint bad';
        startBtn.disabled = false;
      }
    }

    startBtn.addEventListener('click', startAll);

    resetBtn.addEventListener('click', async () => {
      score = 0; combo = 0; scoreEl.textContent = score; comboEl.textContent = combo;
      items.length = 0; ensureItems();
      centroid = { x: W/2, y: H/2 };
      direction = { x: 1, y: 0 };
      updateHint('idle');
      running = false; gameOver = false;
      clearInterval(timerId);
      timeLeft = 60; timeEl.textContent = timeLeft;
      startBtn.disabled = false;
      await stopStream();
      detected = false;
      consecutiveFound = consecutiveLost = 0;
    });

    toggleFacingBtn.addEventListener('click', async () => {
      useEnvironment = !useEnvironment;
      await initCamera();
    });
    toggleMirrorBtn.addEventListener('click', () => {
      mirrored = !mirrored;
      applyMirror();
    });
    fullscreenBtn.addEventListener('click', () => {
      const el = document.documentElement;
      if (!document.fullscreenElement) {
        (el.requestFullscreen && el.requestFullscreen()) || (el.webkitRequestFullscreen && el.webkitRequestFullscreen());
      } else {
        (document.exitFullscreen && document.exitFullscreen()) || (document.webkitExitFullscreen && document.webkitExitFullscreen());
      }
    });

    // ======== é¢æ¿é–‹é—œ ========
    function openPanel() {
      panel.classList.add('open');
      panelBackdrop.classList.add('open');
      panel.setAttribute('aria-hidden', 'false');
    }
    function closePanel() {
      panel.classList.remove('open');
      panelBackdrop.classList.remove('open');
      panel.setAttribute('aria-hidden', 'true');
    }
    menuBtn.addEventListener('click', openPanel);
    closePanelBtn.addEventListener('click', closePanel);
    panelBackdrop.addEventListener('click', closePanel);

    // ======== æ»‘æ¡¿æ•¸å€¼åŒæ­¥ ========
    function bindVal(input, labelEl, formatter = v => v) {
      const sync = () => labelEl.textContent = formatter(input.value);
      input.addEventListener('input', sync);
      sync();
    }
    bindVal(hMinEl, hMinVal);
    bindVal(hMaxEl, hMaxVal);
    bindVal(sMinEl, sMinVal);
    bindVal(vMinEl, vMinVal);
    bindVal(sensEl, sensVal);
    bindVal(densEl, densityVal);
    bindVal(speedEl, speedVal);

    // åµæ¸¬é–¾å€¼ç¶å®š
    function bindCfg(input, labelEl, key, mapFn, fmtFn) {
      const sync = () => {
        detectCfg[key] = mapFn(input.value);
        labelEl.textContent = fmtFn(input.value);
      };
      input.addEventListener('input', sync);
      sync();
    }
    bindCfg(areaPpmEl, areaPpmVal, 'areaPpm', v => parseInt(v,10), v => `${v}â€°`);
    bindCfg(minSideEl, minSideVal, 'minSide', v => parseInt(v,10), v => `${v}`);
    bindCfg(ratioTolEl, ratioTolVal, 'ratioTol', v => parseInt(v,10)/100, v => (parseInt(v,10)/100).toFixed(2)+'Ã—');
    bindCfg(angleCosEl, angleCosVal, 'angleCos', v => parseInt(v,10)/100, v => (parseInt(v,10)/100).toFixed(2));
    bindCfg(minPeriEl, minPeriVal, 'minPeri', v => parseInt(v,10), v => `${v}`);
    bindCfg(thrBlockEl, thrBlockVal, 'blockSize', v => parseInt(v,10)|1, v => `${v}`);
    bindCfg(thrOffsetEl, thrOffsetVal, 'offset', v => parseInt(v,10), v => `${v}`);
    bindCfg(foundFramesEl, foundFramesVal, 'foundFrames', v => parseInt(v,10), v => `${v}`);
    bindCfg(lostFramesEl, lostFramesVal, 'lostFrames', v => parseInt(v,10), v => `${v}`);

    // åˆå§‹
    centroid = { x: W/2, y: H/2 };
    direction = { x: 1, y: 0 };
  </script>
</body>
</html>
