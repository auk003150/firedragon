<!DOCTYPE html>
<html>
<head>
    <title>WebAR æ–°æ˜¥ç¢°æ’éŠæˆ² (å…¨è¢å¹•ç–Šåœ–ç‰ˆ)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, viewport-fit=cover">
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    
    <style>
        html, body { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            height: 100dvh; 
            overflow: hidden; 
            font-family: 'Microsoft YaHei', sans-serif; 
            background-color: #000; 
        }
        
        /* --- 1. æ”å½±æ©Ÿè¨­ç‚ºå…¨è¢å¹• --- */
        #arjs-video {
            transform: scaleX(-1) !important;
            max-width: none !important;
            width: 100% !important;
            height: 100% !important; /* å…¨è¢å¹•é«˜åº¦ */
            object-fit: cover !important;
            z-index: 0 !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
        }

        /* --- 2. èƒŒæ™¯åœ–å±¤ï¼šè¦†è“‹å…¨è¢å¹•ä¸¦è¨­ç‚º 30% é€æ˜åº¦ --- */
        #global-bg {
            position: absolute;
            top: 0; left: 0; 
            width: 100%; height: 100%;
            /* é€™è£¡è«‹æ›æˆæ‚¨çš„èƒŒæ™¯åœ– */
            background: url('image_1.png') no-repeat center center;
            background-size: cover;
            z-index: 1; /* åœ¨å½±ç‰‡ä¹‹ä¸Š */
            pointer-events: none; /* è®“é»æ“Šç©¿é€ */
            opacity: 0.3; /* é—œéµï¼šé€æ˜åº¦ 30% */
        }

        /* --- 3. UI å±¤ï¼šå…¨è¢å¹• --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; 
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10; /* åœ¨èƒŒæ™¯åœ–ä¹‹ä¸Š */
            overflow: hidden;
        }

        /* åˆ†æ•¸èˆ‡æ™‚é–“é¢æ¿ */
        #score-board {
            position: absolute;
            top: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 15px;
            border: 3px solid #d32f2f;
            font-size: 24px;
            font-weight: bold;
            color: #d32f2f;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        #timer-board {
            position: absolute;
            top: 20px; right: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 15px;
            border: 3px solid #1976d2;
            font-size: 24px;
            font-weight: bold;
            color: #1976d2;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        /* æº–å¿ƒæ¨£å¼ */
        #aim-cursor {
            position: absolute;
            width: 100px; height: 100px;
            border: 3px dashed #FFD700;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            transition: opacity 0.1s;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 15;
        }
        
        #aim-cursor::after {
            content: '+';
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
        }

        /* æ¼‚æµ®ç‰©é«” */
        .floating-item {
            position: absolute;
            font-size: 45px;
            font-weight: bold;
            user-select: none;
            will-change: left, top;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 80px; height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 5;
        }

        .good-item { color: #d32f2f; border: 3px solid #d32f2f; }
        .bad-item { color: #333; border: 3px solid #555; }

        .hit-effect {
            transform: scale(1.4);
            background: #fffacd !important;
        }

        .score-popup {
            position: absolute;
            font-size: 40px;
            font-weight: 900;
            text-shadow: 2px 2px 0px #fff;
            animation: floatUp 0.8s ease-out forwards;
            z-index: 20;
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-80px) scale(1.5); }
        }

        /* é®ç½©å±¤ (é–‹å§‹/çµæŸç•«é¢) */
        .overlay-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.75); 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            pointer-events: auto;
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        button {
            padding: 15px 40px;
            font-size: 24px;
            background: #d32f2f;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 30px;
            font-weight: bold;
            box-shadow: 0 0 20px #ff5252;
            transition: transform 0.1s;
            -webkit-tap-highlight-color: transparent;
        }
        button:active { transform: scale(0.95); }
    </style>
</head>
<body>

    <!-- èƒŒæ™¯åœ–å±¤ (å…¨è¢å¹•, opacity 0.3) -->
    <div id="global-bg"></div>

    <!-- éŠæˆ² UI å±¤ (å…¨è¢å¹•) -->
    <div id="ui-layer">
        <div id="score-board">åˆ†æ•¸: <span id="score">0</span></div>
        <div id="timer-board">æ™‚é–“: <span id="timer">60</span></div>
        
        <div id="aim-cursor"></div>
        <div id="game-area"></div>
    </div>

    <!-- é–‹å§‹ç•«é¢ -->
    <div id="start-screen" class="overlay-screen">
        <h1 style="font-size: 42px; margin-bottom: 10px; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">ğŸ§§ WebAR æ–°æ˜¥å¤§ç¢°æ’ ğŸ§§</h1>
        <p style="font-size: 18px; color: #ddd; margin-bottom: 20px;">è«‹æº–å‚™å¥½ Hiro Marker</p>
        
        <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.2);">
            <p style="margin: 10px 0;">â±ï¸ é™æ™‚ï¼š<span style="color:#4fc3f7; font-weight:bold;">60 ç§’</span></p>
            <p style="margin: 10px 0;">ğŸ”´ ç¢°åˆ°ç´…å­—ï¼š<span style="color:#ff5252; font-weight:bold;">+15 åˆ†</span></p>
            <p style="margin: 10px 0;">âš« ç¢°åˆ°é›œç‰©ï¼š<span style="color:#aaa; font-weight:bold;">-5 åˆ†</span></p>
        </div>
        
        <button onclick="startGame()">é–‹å§‹éŠæˆ²</button>
    </div>

    <!-- éŠæˆ²çµæŸç•«é¢ -->
    <div id="game-over-screen" class="overlay-screen" style="display: none;">
        <h1 style="font-size: 48px; color: #FFD700; text-shadow: 0 2px 10px rgba(0,0,0,0.8);">æ™‚é–“åˆ°ï¼</h1>
        <p style="font-size: 24px;">æœ€çµ‚åˆ†æ•¸</p>
        <div style="font-size: 80px; font-weight: bold; color: #fff; margin: 10px 0; text-shadow: 0 4px 15px rgba(211, 47, 47, 0.8);">
            <span id="final-score">0</span>
        </div>
        <button onclick="startGame()">å†ç©ä¸€æ¬¡</button>
    </div>

    <!-- AR å ´æ™¯ -->
    <a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;' vr-mode-ui="enabled: false">
        <a-entity camera></a-entity>
        <a-marker preset="hiro" id="player-marker"></a-marker>
    </a-scene>

    <script>
        const goodWords = ['ç¦', 'æ˜¥', 'è²¡', 'å®‰', 'æ—º', 'å‰', 'ç¥¥', 'è³€', 'é¾', 'å¹´'];
        const badWords = ['âš½', 'ğŸ”', 'ğŸ§', 'ğŸ§Š', 'ğŸ§¼', 'ğŸº', 'ğŸ’¡', 'ğŸ“', 'ğŸ§½', 'ğŸ§¯'];
        
        let score = 0;
        let timeLeft = 60;
        let isGameRunning = false;
        let items = []; 
        let timerInterval = null;

        const gameArea = document.getElementById('game-area');
        const scoreEl = document.getElementById('score');
        const timerEl = document.getElementById('timer');
        const playerMarker = document.getElementById('player-marker');
        const aimCursor = document.getElementById('aim-cursor');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        
        // å–å¾—è¦–çª—å¤§å°ä½œç‚ºéŠæˆ²é‚Šç•Œ
        let gameHeight = window.innerHeight;
        let gameWidth = window.innerWidth;

        let playerScreenPos = { x: -1000, y: -1000, visible: false };

        function startGame() {
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            
            score = 0;
            timeLeft = 60;
            scoreEl.innerText = score;
            timerEl.innerText = timeLeft;
            timerEl.style.color = '#1976d2';

            gameArea.innerHTML = '';
            items = [];

            // æ›´æ–°éŠæˆ²å€åŸŸå¤§å°
            gameHeight = window.innerHeight;
            gameWidth = window.innerWidth;

            isGameRunning = true;
            
            // å¢åŠ ç”Ÿæˆæ•¸é‡ï¼Œå› ç‚ºç•«é¢è®Šå¤§äº†
            spawnItems(8, 'good'); 
            spawnItems(5, 'bad');  
            
            gameLoop();

            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeLeft--;
                timerEl.innerText = timeLeft;

                if (timeLeft <= 10) {
                    timerEl.style.color = '#d32f2f';
                }

                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }

        function endGame() {
            isGameRunning = false;
            clearInterval(timerInterval);
            finalScoreEl.innerText = score;
            gameOverScreen.style.display = 'flex';
        }

        function spawnItems(count, type) {
            for (let i = 0; i < count; i++) {
                const el = document.createElement('div');
                el.classList.add('floating-item');
                
                let text = '';
                if (type === 'good') {
                    text = goodWords[Math.floor(Math.random() * goodWords.length)];
                    el.classList.add('good-item');
                    el.dataset.points = 15;
                } else {
                    text = badWords[Math.floor(Math.random() * badWords.length)];
                    el.classList.add('bad-item');
                    el.dataset.points = -5;
                }
                
                el.innerText = text;
                gameArea.appendChild(el);

                const size = 80; 
                const itemObj = {
                    element: el,
                    x: Math.random() * (gameWidth - size),
                    y: Math.random() * (gameHeight - size),
                    vx: (Math.random() - 0.5) * 5, // ç¨å¾®èª¿æ•´é€Ÿåº¦
                    vy: (Math.random() - 0.5) * 5, 
                    width: size,
                    height: size,
                    active: true
                };
                items.push(itemObj);
            }
        }

        function gameLoop() {
            if (!isGameRunning) return;
            updatePlayerPosition();
            updateItems();
            checkCollisions();
            requestAnimationFrame(gameLoop);
        }

        function updatePlayerPosition() {
            if (playerMarker.object3D.visible) {
                const vector = new THREE.Vector3();
                playerMarker.object3D.getWorldPosition(vector);
                
                const camera = document.querySelector('a-scene').camera;
                vector.project(camera);

                // å…¨è¢å¹•åº§æ¨™è½‰æ›
                const screenX = ((-vector.x + 1) / 2) * window.innerWidth;
                const screenY = ((-vector.y + 1) / 2) * window.innerHeight;

                playerScreenPos.x = screenX;
                playerScreenPos.y = screenY;
                playerScreenPos.visible = true;

                aimCursor.style.display = 'flex';
                aimCursor.style.left = screenX + 'px';
                aimCursor.style.top = screenY + 'px';
                
                // æª¢æŸ¥æ˜¯å¦è¶…å‡ºè¢å¹•é‚Šç•Œ
                if (screenX < 0 || screenX > gameWidth || screenY < 0 || screenY > gameHeight) {
                    aimCursor.style.borderColor = '#ccc';
                    aimCursor.style.opacity = '0.5';
                } else {
                    aimCursor.style.borderColor = '#FFD700';
                    aimCursor.style.opacity = '1';
                }

            } else {
                playerScreenPos.visible = false;
                aimCursor.style.display = 'none';
            }
        }

        function updateItems() {
            items.forEach(item => {
                if (!item.active) return;
                item.x += item.vx;
                item.y += item.vy;

                // ç¢°åˆ°è¦–çª—é‚Šç·£åå½ˆ
                if (item.x <= 0 || item.x >= gameWidth - item.width) {
                    item.vx *= -1;
                    item.x = Math.max(0, Math.min(item.x, gameWidth - item.width));
                }
                if (item.y <= 0 || item.y >= gameHeight - item.height) {
                    item.vy *= -1;
                    item.y = Math.max(0, Math.min(item.y, gameHeight - item.height));
                }

                item.element.style.left = item.x + 'px';
                item.element.style.top = item.y + 'px';
            });
        }

        function checkCollisions() {
            if (!playerScreenPos.visible) return;
            
            const playerReachRadius = 50; 

            items.forEach(item => {
                if (!item.active) return;
                const itemRadius = item.width / 2;
                const itemCenterX = item.x + itemRadius;
                const itemCenterY = item.y + itemRadius;
                const dx = playerScreenPos.x - itemCenterX;
                const dy = playerScreenPos.y - itemCenterY;
                const distSq = dx*dx + dy*dy;
                const threshold = playerReachRadius + itemRadius;

                if (distSq < threshold * threshold) {
                    handleCollision(item);
                }
            });
        }

        function handleCollision(item) {
            const points = parseInt(item.element.dataset.points);
            score += points;
            scoreEl.innerText = score;
            item.element.classList.add('hit-effect');
            showScorePopup(points, item.x, item.y);
            respawnItem(item);
        }

        function showScorePopup(points, x, y) {
            const popup = document.createElement('div');
            popup.classList.add('score-popup');
            popup.innerText = points > 0 ? `+${points}` : points;
            popup.style.color = points > 0 ? '#2e7d32' : '#d32f2f';
            popup.style.left = (x + 20) + 'px';
            popup.style.top = (y - 20) + 'px';
            gameArea.appendChild(popup);
            setTimeout(() => { popup.remove(); }, 800);
        }

        function respawnItem(item) {
            item.active = false;
            item.element.style.transition = 'opacity 0.2s, transform 0.2s';
            item.element.style.opacity = '0';
            item.element.style.transform = 'scale(0)';

            setTimeout(() => {
                if (!isGameRunning) return;

                item.element.classList.remove('hit-effect');
                item.element.style.transition = 'none'; 
                
                if (item.element.classList.contains('good-item')) {
                    item.element.innerText = goodWords[Math.floor(Math.random() * goodWords.length)];
                } else {
                    item.element.innerText = badWords[Math.floor(Math.random() * badWords.length)];
                }

                let newX, newY;
                let safetyTries = 0;
                do {
                    newX = Math.random() * (gameWidth - item.width);
                    newY = Math.random() * (gameHeight - item.height);
                    safetyTries++;
                    const dx = newX - playerScreenPos.x;
                    const dy = newY - playerScreenPos.y;
                    if (Math.sqrt(dx*dx + dy*dy) > 200) break;
                } while (safetyTries < 5);

                item.x = newX;
                item.y = newY;
                item.vx = (Math.random() - 0.5) * 5;
                item.vy = (Math.random() - 0.5) * 5;
                item.active = true;
                
                requestAnimationFrame(() => {
                    item.element.style.transition = 'opacity 0.3s, transform 0.3s';
                    item.element.style.opacity = '1';
                    item.element.style.transform = 'scale(1)';
                });

            }, 400);
        }

        window.addEventListener('resize', () => {
            gameHeight = window.innerHeight;
            gameWidth = window.innerWidth;
            items.forEach(item => {
                item.x = Math.min(item.x, gameWidth - item.width);
                item.y = Math.min(item.y, gameHeight - item.height);
            });
        });
    </script>
</body>
</html>
