<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>å¤§å‘èˆç«é¾ AR éŠæˆ²</title>

  <!-- A-Frame & AR.js (marker-based) -->
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

  <style>
    :root {
      --glass: rgba(0,0,0,0.52);
      --glass-strong: rgba(0,0,0,0.68);
      --good: #e53935;
      --bad: #455a64;
      --text: #f5f5f5;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden;
      background: #000 url('image_1.png') center/cover fixed no-repeat;
      color: var(--text);
      font-family: "Segoe UI", "Noto Sans TC", system-ui, -apple-system, sans-serif;
    }
    body.bg-off { background: #000; }
    a-scene {
      position: fixed !important;
      top: 0; left: 0; width: 100vw; height: 100vh;
      z-index: 0;
    }
    .hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      padding: 12px;
      gap: 8px;
      z-index: 5;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      pointer-events: auto;
    }
    .card {
      padding: 10px 12px;
      border-radius: 12px;
      background: var(--glass);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 8px 20px rgba(0,0,0,0.35);
      color: var(--text);
      font-size: 14px;
      line-height: 1.35;
    }
    .card strong { color: #fff; font-size: 15px; }
    .tag {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 32px;
      padding: 4px 8px;
      border-radius: 999px;
      font-weight: 700;
      font-size: 14px;
    }
    .tag.good { background: var(--good); color: #fff; }
    .tag.bad { background: var(--bad); color: #fff; }
    .btn {
      padding: 8px 14px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.16);
      background: var(--glass-strong);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.12s ease, background 0.15s ease;
    }
    .btn:hover { background: rgba(255,255,255,0.12); }
    .btn:active { transform: scale(0.97); }
    .status-dot {
      width: 10px; height: 10px; border-radius: 50%;
      background: #f44336; margin-right: 6px; display: inline-block;
      box-shadow: 0 0 0 0 rgba(244,67,54,0.6);
      animation: pulse 1.4s infinite;
    }
    .status-dot.on { background: #4caf50; box-shadow: 0 0 0 8px rgba(76,175,80,0); }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(76,175,80,0.35); }
      70% { box-shadow: 0 0 0 12px rgba(76,175,80,0); }
      100% { box-shadow: 0 0 0 0 rgba(76,175,80,0); }
    }
    .bottom-note {
      margin-top: auto;
      font-size: 13px;
      opacity: 0.9;
      pointer-events: auto;
    }
    .flex-gap { display: flex; gap: 6px; flex-wrap: wrap; align-items: center; }
    .pill {
      padding: 6px 10px;
      background: rgba(255,255,255,0.08);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .toast {
      position: fixed;
      left: 50%; top: 16px;
      transform: translateX(-50%) translateY(-10px);
      padding: 10px 14px;
      background: rgba(0,0,0,0.78);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      color: #fff;
      font-weight: 700;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease, transform 0.25s ease;
      z-index: 6;
    }
    .toast.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    @media (max-width: 700px) {
      .card { width: 100%; }
      .row { width: 100%; }
    }
  </style>
</head>
<body class="bg-on">
  <div class="hud">
    <div class="row">
      <div class="card">
        <div class="flex-gap" style="margin-bottom:4px;">
          <span class="status-dot" id="markerDot"></span>
          <strong>Marker ç‹€æ…‹ï¼š</strong><span id="markerState">æœªåµæ¸¬</span>
        </div>
        <div class="flex-gap">
          <div class="pill">åˆ†æ•¸ï¼š<strong id="scoreText">0</strong></div>
          <div class="pill">å€’æ•¸ï¼š<strong id="timeText">60s</strong></div>
          <div class="pill">ç‹€æ…‹ï¼š<strong id="gameState">å¾…é–‹å§‹</strong></div>
        </div>
      </div>
      <div class="row" style="gap:6px;">
        <button class="btn" id="startBtn">é–‹å§‹ / æš«åœ</button>
        <button class="btn" id="resetBtn">é‡ç½®</button>
        <button class="btn" id="mirrorBtn">é¡åƒé–‹é—œ</button>
        <button class="btn" id="bgBtn">èƒŒæ™¯é–‹é—œ</button>
      </div>
    </div>

    <div class="card">
      <div class="flex-gap" style="margin-bottom:6px;">
        <strong>ç¢°æ’è¦å‰‡ï¼š</strong>
        <span class="tag good">+1</span> æ’ã€Œç¦æ˜¥è²¡å®‰æ—ºå‰ç¥¥è³€é¾å¹´ã€
        <span class="tag bad">-1</span> æ’ã€Œâš½ ğŸ” ğŸ§ ğŸ§Š ğŸ§¼ ğŸº ğŸ’¡ ğŸ“ ğŸ§½ ğŸ§¯ã€
      </div>
      <div class="flex-gap">
        <div>å¥½å­—ï¼šç¦ã€æ˜¥ã€è²¡ã€å®‰ã€æ—ºã€å‰ã€ç¥¥ã€è³€ã€é¾ã€å¹´</div>
        <div>å£å­—ï¼šâš½ã€ğŸ”ã€ğŸ§ã€ğŸ§Šã€ğŸ§¼ã€ğŸºã€ğŸ’¡ã€ğŸ“ã€ğŸ§½ã€ğŸ§¯</div>
      </div>
    </div>

    <div class="card bottom-note">
      èªªæ˜ï¼šåœ¨ 60 ç§’å…§ç§»å‹•ã€Œhiroã€marker è®“ç«é¾å»æ’ç´…è‰²å¥½å­—å¾—åˆ†ï¼Œæ’ç°è‰²å£å­—æœƒæ‰£åˆ†ã€‚å»ºè­°åœ¨å…‰ç·šå……è¶³çš„åœ°æ–¹ä½¿ç”¨ HTTPSï¼ˆGitHub Pages é è¨­æ”¯æ´ï¼‰ã€‚
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <a-scene
    embedded
    vr-mode-ui="enabled: false"
    renderer="logarithmicDepthBuffer: true; alpha: true; antialias: true"
    arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;"
    id="scene">
    
    <a-assets></a-assets>

    <!-- Marker anchor -->
    <a-marker preset="hiro" id="marker">
      <a-entity id="dragon" position="0 0 0" scale="1 1 1"></a-entity>
    </a-marker>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    // Face-camera billboard component
    AFRAME.registerComponent('face-camera', {
      tick: function () {
        const cam = this.el.sceneEl && this.el.sceneEl.camera;
        if (!cam) return;
        this.el.object3D.quaternion.copy(cam.quaternion);
      }
    });

    // Floating animation helper
    AFRAME.registerComponent('floaty', {
      schema: { amp: {default: 0.05}, speed: {default: 1} },
      init: function () {
        this.t0 = Math.random() * Math.PI * 2;
        this.baseY = this.el.object3D.position.y || 0;
      },
      tick: function (t) {
        const y = Math.sin((t / 1000) * this.data.speed + this.t0) * this.data.amp;
        this.el.object3D.position.y = this.baseY + y;
      },
      update: function () {
        this.baseY = this.el.object3D.position.y || 0;
      }
    });

    // ---------- Fire Dragon model: single upright bamboo + spiky incense ball ----------
    function buildFireDragon() {
      const dragon = document.getElementById('dragon');
      while (dragon.firstChild) dragon.removeChild(dragon.firstChild);

      const bamboo = '#8d6e63';
      const darkBamboo = '#6d4c41';
      const incense = '#d9c19f';
      const glow = '#ffcc80';

      // Upright bamboo pole
      const pole = document.createElement('a-cylinder');
      pole.setAttribute('position', '0 0.4 0');
      pole.setAttribute('radius', 0.04);
      pole.setAttribute('height', 0.8);
      pole.setAttribute('color', bamboo);
      pole.setAttribute('roughness', 1);
      dragon.appendChild(pole);

      // Small handle base
      const base = document.createElement('a-cylinder');
      base.setAttribute('position', '0 0 0');
      base.setAttribute('radius', 0.06);
      base.setAttribute('height', 0.12);
      base.setAttribute('color', darkBamboo);
      base.setAttribute('roughness', 1);
      dragon.appendChild(base);

      // Spiky incense ball at top
      const ballGroup = document.createElement('a-entity');
      ballGroup.setAttribute('position', '0 0.85 0');

      const core = document.createElement('a-sphere');
      core.setAttribute('radius', 0.09);
      core.setAttribute('color', darkBamboo);
      core.setAttribute('opacity', 0.95);
      ballGroup.appendChild(core);

      const spikes = 48;
      const radius = 0.2;
      for (let i=0; i<spikes; i++){
        const phi = Math.acos(1 - 2*(i+0.5)/spikes);
        const theta = Math.PI * (1 + Math.sqrt(5)) * i;
        const dir = new THREE.Vector3(
          Math.cos(theta) * Math.sin(phi),
          Math.cos(phi),
          Math.sin(theta) * Math.sin(phi)
        );
        const len = radius * (0.9 + Math.random()*0.4);
        const mid = dir.clone().multiplyScalar(len*0.5);
        const spike = document.createElement('a-cylinder');
        spike.setAttribute('radius', 0.007);
        spike.setAttribute('height', len);
        spike.setAttribute('color', incense);
        spike.object3D.position.set(mid.x, mid.y, mid.z);
        spike.object3D.lookAt(dir.clone().multiplyScalar(len));
        ballGroup.appendChild(spike);

        const tip = document.createElement('a-sphere');
        tip.setAttribute('radius', 0.012);
        tip.setAttribute('color', glow);
        tip.setAttribute('emissive', glow);
        tip.object3D.position.set(dir.x * len, dir.y * len, dir.z * len);
        ballGroup.appendChild(tip);
      }
      dragon.appendChild(ballGroup);
    }
    // ---------------------------------------------------------------

    const goodWords = ['ç¦','æ˜¥','è²¡','å®‰','æ—º','å‰','ç¥¥','è³€','é¾','å¹´'];
    const badWords  = ['âš½','ğŸ”','ğŸ§','ğŸ§Š','ğŸ§¼','ğŸº','ğŸ’¡','ğŸ“','ğŸ§½','ğŸ§¯'];
    let score = 0;
    let timeLeft = 60;
    let running = false;
    let spawnTimer = null;
    let countdownTimer = null;
    const targets = new Map(); // id -> {el, isGood}

    const scoreText = document.getElementById('scoreText');
    const timeText = document.getElementById('timeText');
    const gameStateText = document.getElementById('gameState');
    const markerState = document.getElementById('markerState');
    const markerDot = document.getElementById('markerDot');
    const toast = document.getElementById('toast');

    const scene = document.getElementById('scene');
    const marker = document.getElementById('marker');

    let arCanvas = null;
    function getCanvas() {
      if (arCanvas && arCanvas.isConnected) return arCanvas;
      arCanvas = scene.canvas || document.querySelector('canvas');
      return arCanvas;
    }

    // Show toast
    function showToast(msg) {
      toast.textContent = msg;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 900);
    }

    // Texture cache for labels
    const texCache = {};
    function roundedRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.lineTo(x+w-r, y);
      ctx.quadraticCurveTo(x+w, y, x+w, y+r);
      ctx.lineTo(x+w, y+h-r);
      ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
      ctx.lineTo(x+r, y+h);
      ctx.quadraticCurveTo(x, y+h, x, y+h-r);
      ctx.lineTo(x, y+r);
      ctx.quadraticCurveTo(x, y, x+r, y);
      ctx.closePath();
    }
    function makeLabelTexture(word, bgColor) {
      const key = word + '|' + bgColor;
      if (texCache[key]) return texCache[key];
      const size = 256;
      const c = document.createElement('canvas');
      c.width = size; c.height = size;
      const ctx = c.getContext('2d');
      ctx.clearRect(0,0,size,size);

      const pad = 12;
      roundedRect(ctx, pad, pad, size-2*pad, size-2*pad, 28);
      ctx.fillStyle = bgColor;
      ctx.fill();

      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = 'bold 170px "Noto Sans TC","Microsoft JhengHei","PingFang TC","Heiti TC",sans-serif';
      let fsize = 170;
      while (true) {
        const metrics = ctx.measureText(word);
        const w = metrics.width;
        if (w < size - 60 || fsize < 80) break;
        fsize -= 10;
        ctx.font = `bold ${fsize}px "Noto Sans TC","Microsoft JhengHei","PingFang TC","Heiti TC",sans-serif`;
      }
      ctx.fillText(word, size/2, size/2 + 8);

      const url = c.toDataURL('image/png');
      texCache[key] = url;
      return url;
    }

    function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    function rand(min,max){ return Math.random()*(max-min)+min; }

    // Spawn a target into the world (not parented to marker)
    let targetId = 0;
    function spawnTarget() {
      if (!running) return;
      const isGood = Math.random() < 0.7;
      const word = isGood ? pick(goodWords) : pick(badWords);
      const bgColor = isGood ? '#d32f2f' : '#455a64';
      const tex = makeLabelTexture(word, bgColor);

      const el = document.createElement('a-entity');
      el.setAttribute('geometry', 'primitive: plane; width: 0.5; height: 0.5');
      el.setAttribute('material', `src: ${tex}; transparent: true; side: double; alphaTest: 0.01;`);
      el.setAttribute('face-camera', '');
      el.setAttribute('floaty', `amp: 0.04; speed: ${rand(0.6,1.2)}`);

      const x = rand(-1.4, 1.4);
      const y = rand(0.4, 1.6);
      const z = rand(-2.4, -0.9);
      el.object3D.position.set(x, y, z);

      const id = ++targetId;
      el.dataset.id = id;
      el.dataset.isGood = isGood ? '1' : '0';

      scene.appendChild(el);
      targets.set(id, { el, isGood });

      setTimeout(() => {
        if (targets.has(id)) {
          scene.removeChild(el);
          targets.delete(id);
        }
      }, 6000);
    }

    // Collision detection each tick
    scene.addEventListener('loaded', () => {
      scene.setAttribute('game-manager','');
      buildFireDragon();
    });

    AFRAME.registerComponent('game-manager', {
      tick: function () {
        if (!running) return;
        if (!marker.object3D.visible) return;
        const markerWorld = new THREE.Vector3();
        marker.object3D.getWorldPosition(markerWorld);

        targets.forEach((obj, id) => {
          if (!obj.el.object3D) return;
          const pos = new THREE.Vector3();
          obj.el.object3D.getWorldPosition(pos);
          const dist = markerWorld.distanceTo(pos);
          if (dist < 0.35) {
            const isGood = obj.isGood;
            score += isGood ? 1 : -1;
            scoreText.textContent = score;
            showToast(isGood ? '+1 å¾—åˆ†ï¼' : '-1 æ‰£åˆ†ï¼');
            obj.el.setAttribute('material', 'color', isGood ? '#ffeb3b' : '#000');
            setTimeout(() => {
              if (obj.el.parentNode) scene.removeChild(obj.el);
            }, 80);
            targets.delete(id);
          }
        });
      }
    });

    // Marker events
    marker.addEventListener('markerFound', () => {
      markerState.textContent = 'å·²åµæ¸¬';
      markerDot.classList.add('on');
    });
    marker.addEventListener('markerLost', () => {
      markerState.textContent = 'æœªåµæ¸¬';
      markerDot.classList.remove('on');
    });

    // Timer logic
    function startGame() {
      if (running) { pauseGame(); return; }
      clearInterval(countdownTimer);
      clearInterval(spawnTimer);

      running = true;
      gameStateText.textContent = 'é€²è¡Œä¸­';
      countdownTimer = setInterval(() => {
        timeLeft -= 1;
        if (timeLeft < 0) timeLeft = 0;
        timeText.textContent = timeLeft + 's';
        if (timeLeft <= 0) {
          endGame();
        }
      }, 1000);
      spawnTimer = setInterval(spawnTarget, 1400);
      showToast('é–‹å§‹ï¼60 ç§’è¨ˆæ™‚ä¸­');
    }

    function pauseGame() {
      running = false;
      gameStateText.textContent = 'å·²æš«åœ';
      clearInterval(countdownTimer);
      clearInterval(spawnTimer);
      showToast('å·²æš«åœ');
    }

    function endGame() {
      running = false;
      clearInterval(countdownTimer);
      clearInterval(spawnTimer);
      gameStateText.textContent = 'å·²çµæŸ';
      showToast('æ™‚é–“åˆ°ï¼ç¸½åˆ†ï¼š' + score);
    }

    function resetGame() {
      running = false;
      clearInterval(countdownTimer);
      clearInterval(spawnTimer);
      timeLeft = 60;
      score = 0;
      scoreText.textContent = score;
      timeText.textContent = timeLeft + 's';
      gameStateText.textContent = 'å¾…é–‹å§‹';
      targets.forEach(obj => {
        if (obj.el.parentNode) scene.removeChild(obj.el);
      });
      targets.clear();
      showToast('å·²é‡ç½®');
    }

    // UI buttons
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('resetBtn').addEventListener('click', resetGame);

    // Mirror toggle (é¡åƒé–‹é—œ)
    let mirrorOn = false;
    document.getElementById('mirrorBtn').addEventListener('click', () => {
      const c = getCanvas();
      if (!c) { showToast('ç­‰å¾…ç•«é¢åˆå§‹åŒ–â€¦'); return; }
      mirrorOn = !mirrorOn;
      c.style.transformOrigin = 'center center';
      c.style.transform = mirrorOn ? 'scaleX(-1)' : 'scaleX(1)';
      showToast(mirrorOn ? 'é¡åƒï¼šé–‹' : 'é¡åƒï¼šé—œ');
    });

    // Background toggle
    let bgOn = true;
    document.getElementById('bgBtn').addEventListener('click', () => {
      bgOn = !bgOn;
      document.body.classList.toggle('bg-off', !bgOn);
      showToast(bgOn ? 'èƒŒæ™¯åœ–ï¼šé–‹' : 'èƒŒæ™¯åœ–ï¼šé—œ');
    });
  </script>
</body>
</html>
