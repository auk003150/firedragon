<!doctype html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>æ–°æ˜¥å¤§å‘èˆç«é¾éŠæˆ² (Optimized)</title>

  <style>
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden; font-family: system-ui, -apple-system, "Microsoft YaHei", sans-serif;
      background: #000;
      position: relative; /* Needed for absolute positioning of children */
    }

    /* Background MP4 */
    #bg-video {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      object-fit: cover;
      z-index: 0;
      opacity: 0.85;
      pointer-events: none;
    }

    /* Camera background (visible so you can see your face) */
    #video {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      opacity: 0.15;
      z-index: 1;
    }

    /* NEW: Canvas for all game rendering */
    #game-canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
    }

    /* UI layer (Score, Timer, Overlays) */
    #ui-layer {
      position: absolute; inset: 0;
      pointer-events: none;
      z-index: 10;
      color: #fff;
    }

    /* OPTIMIZED: Removed expensive backdrop-filter */
    #score-board, #timer-board {
      position: absolute; top: 16px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 16px;
      border-radius: 14px;
      font-size: 18px;
      font-weight: 800;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.25);
    }
    #score-board { left: 16px; color: #ffeb3b; text-shadow: 0 0 5px #ff5722; }
    #timer-board { right: 16px; }

    /* Overlays (Start/End screens) */
    .overlay-screen {
      position: absolute; inset: 0;
      background: rgba(0,0,0,0.82);
      display: flex; flex-direction: column;
      justify-content: center; align-items: center;
      z-index: 40;
      pointer-events: auto;
      text-align: center;
      padding: 18px;
    }
    .overlay-screen button {
      pointer-events: auto;
      padding: 14px 34px;
      font-size: 20px;
      background: #d32f2f;
      color: #fff;
      border: none;
      border-radius: 999px;
      cursor: pointer;
      margin-top: 16px;
      font-weight: 900;
      box-shadow: 0 0 15px rgba(255,82,82,0.8);
      transition: transform 0.1s;
    }
    .overlay-screen button:active { transform: scale(0.97); }

    #mute-btn {
      position: absolute; bottom: 16px; right: 16px;
      z-index: 50;
      background: rgba(255,255,255,0.5);
      border: none;
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 22px;
      cursor: pointer;
      pointer-events: auto;
      user-select: none;
    }
  </style>
</head>

<body>
  <!-- Background Video -->
  <video id="bg-video" autoplay muted loop playsinline preload="auto">
    <source src="animated.mp4" type="video/mp4" />
  </video>

  <!-- Audio elements remain the same -->
  <audio id="bgm" loop src="bgm.mp3"></audio>
  <audio id="sfx-collect" src="Collect.mp3"></audio>
  <audio id="sfx-crunch" src="Crunch.mp3"></audio>
  <audio id="sfx-end" src="end.mp3"></audio>

  <!-- Webcam Video for MediaPipe -->
  <video id="video" playsinline autoplay muted></video>

  <!-- NEW: Canvas element for rendering the game -->
  <canvas id="game-canvas"></canvas>

  <!-- UI Layer remains, but dragon and game items are removed from it -->
  <div id="ui-layer">
    <div id="score-board">åˆ†æ•¸: <span id="score">0</span></div>
    <div id="timer-board">æ™‚é–“: <span id="timer">60</span></div>

    <button id="mute-btn" title="Mute/unmute">ğŸ”Š</button>

    <div id="start-screen" class="overlay-screen">
      <h1 style="color:#ffeb3b; text-shadow: 0 0 10px #ff5722; font-size: 38px; margin:0;">ğŸ”¥ å¤§å‘èˆç«é¾ ğŸ”¥</h1>
      <p style="font-size: 16px; color: #ddd; margin: 10px 0 0;">
        ç”¨ã€Œå³æ‰‹æ‰‹è…•ã€æ§åˆ¶é¾é ­æ”¶é›†å‰ç¥¥å­—ï¼<br>é¿é–‹ Emoji æ³¡æ³¡ã€‚
      </p>
      <button id="startBtn">èµ·é¾ï¼(Start)</button>
      <div id="err" style="margin-top:10px; display:none;"></div>
    </div>

    <div id="game-over-screen" class="overlay-screen" style="display:none;">
      <h1 style="margin:0 0 10px;">æ™‚é–“åˆ°ï¼</h1>
      <p style="margin:0;">æœ€çµ‚åˆ†æ•¸: <span id="final-score" style="font-size: 40px; font-weight: 900; color: #ffeb3b;">0</span></p>
      <button id="restartBtn2">å†èˆä¸€æ¬¡</button>
    </div>
  </div>

  <script type="module">
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

    // --- Constants ---
    const MODEL_URL = "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task";
    const goodWords = ['ç¦', 'æ˜¥', 'è²¡', 'å®‰', 'æ—º', 'å‰', 'ç¥¥', 'è³€', 'é¦¬', 'å¹´'];
    const badWords  = ['âš½', 'ğŸ”', 'ğŸ§', 'ğŸ§Š', 'ğŸ§¼', 'ğŸº', 'ğŸ’¡', 'ğŸ“', 'ğŸ§½', 'ğŸ§¯'];
    const GAME_SECONDS = 60;
    const GOOD_POINTS = 10;
    const BAD_POINTS  = -5;
    const SMOOTHING = 0.22;
    const HEAD_R = 60; // Collision radius for head
    const ITEM_R = 35; // Collision radius for items

    // Dragon Body Constants
    const bodySegmentCount = 14;
    const bodySpacing = 26;

    // --- DOM Elements ---
    const video = document.getElementById('video');
    const bgVideo = document.getElementById('bg-video');
    const scoreEl = document.getElementById('score');
    const timerEl = document.getElementById('timer');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreEl = document.getElementById('final-score');
    const startBtn = document.getElementById('startBtn');
    const restartBtn2 = document.getElementById('restartBtn2');
    const errEl = document.getElementById('err');
    const sounds = {
      bgm: document.getElementById('bgm'),
      collect: document.getElementById('sfx-collect'),
      crunch: document.getElementById('sfx-crunch'),
      end: document.getElementById('sfx-end')
    };

    // --- NEW: Canvas Setup ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');

    // --- Game State ---
    let score = 0;
    let timeLeft = GAME_SECONDS;
    let items = [];
    let popups = []; // For score popups
    let timerInterval = null;
    let gameWidth = window.innerWidth;
    let gameHeight = window.innerHeight;
    let cursor = { x: -100, y: -100, visible: false };
    let mirror = true; // webcam is mirrored
    let isMuted = false;
    let isGameRunning = false;

    // Dragon body positions array (logic remains, rendering changes)
    const bodyPositions = [];

    // --- Sound Logic (Unchanged) ---
    sounds.bgm.volume = 0.3;
    sounds.collect.volume = 0.85;
    sounds.crunch.volume = 0.85;
    sounds.end.volume = 0.75;
    function playSound(name) {
      if (isMuted) return;
      const a = sounds[name];
      if (!a) return;
      a.currentTime = 0;
      a.play().catch(() => {});
    }
    function setMuted(m) {
      isMuted = m;
      document.getElementById('mute-btn').textContent = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
      if (isMuted) { sounds.bgm.pause(); }
      else { if (isGameRunning) sounds.bgm.play().catch(()=>{}); }
    }
    document.getElementById('mute-btn').addEventListener('click', () => setMuted(!isMuted));
    bgVideo.muted = true;

    // --- Dragon & Game Initialization ---
    function initDragonBody() {
      bodyPositions.length = 0;
      // The +1 is for the tail
      for (let i = 0; i < bodySegmentCount + 1; i++) {
        bodyPositions.push({ x: -200, y: -200, a: 0 });
      }
    }

    // --- MediaPipe Hand Tracking (Unchanged) ---
    let handLandmarker = null;
    let lastVideoTime = -1;
    let wristN = { x: 0.5, y: 0.65 };

    async function initCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
      video.srcObject = stream;
      await video.play();
    }

    async function initHandLandmarker() {
      const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: MODEL_URL },
        runningMode: "VIDEO",
        numHands: 2,
        minHandDetectionConfidence: 0.5,
        minHandPresenceConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
    }

    function updateWristFromLandmarks(result) {
      cursor.visible = false;
      if (!result || !result.landmarks || result.landmarks.length === 0) return;

      let idx = 0;
      if (result.handednesses && result.handednesses.length) {
        const rightIndex = result.handednesses.findIndex(h => h && h[0] && String(h[0].categoryName).toLowerCase() === "right");
        if (rightIndex >= 0) idx = rightIndex;
      }

      const lm = result.landmarks[idx];
      if (!lm || !lm[0]) return;

      let x = lm[0].x;
      let y = lm[0].y;
      if (mirror) x = 1 - x;

      wristN.x += (x - wristN.x) * SMOOTHING;
      wristN.y += (y - wristN.y) * SMOOTHING;

      cursor.x = wristN.x * gameWidth;
      cursor.y = wristN.y * gameHeight;
      cursor.visible = true;
    }

    // --- Game Logic ---

    function spawnItems(count, type) {
      for (let i = 0; i < count; i++) {
        const text = type === 'good'
          ? goodWords[Math.floor(Math.random() * goodWords.length)]
          : badWords[Math.floor(Math.random() * badWords.length)];
        
        const size = 70;
        items.push({
          text: text,
          kind: type,
          points: type === 'good' ? GOOD_POINTS : BAD_POINTS,
          x: Math.random() * (gameWidth - size),
          y: Math.random() * (gameHeight - size),
          vx: (Math.random() - 0.5) * 2.8,
          vy: (Math.random() - 0.5) * 2.8,
          width: size, height: size,
          active: true
        });
      }
    }

    function handleHit(item) {
      score += item.points;
      scoreEl.textContent = String(score);

      if (item.points > 0) playSound('collect');
      else playSound('crunch');
      
      // Create a score popup object instead of a DOM element
      popups.push({
        text: item.points > 0 ? `+${item.points}` : String(item.points),
        color: item.points > 0 ? '#2e7d32' : '#d32f2f',
        x: item.x,
        y: item.y,
        alpha: 1,
        life: 1, // 1 = 100% life
      });

      item.active = false; // Item becomes inactive

      // Respawn the item after a delay
      setTimeout(() => {
        if (!isGameRunning) return;
        item.active = true;
        item.x = Math.random() * (gameWidth - item.width);
        item.y = Math.random() * (gameHeight - item.height);
        item.text = item.kind === 'good'
          ? goodWords[Math.floor(Math.random() * goodWords.length)]
          : badWords[Math.floor(Math.random() * badWords.length)];
      }, 450);
    }

    // --- UPDATE Function (All Game Logic) ---
    function update() {
      if (!isGameRunning) return;

      // Update hand tracking
      if (video.readyState >= 2 && handLandmarker && video.currentTime !== lastVideoTime) {
        const res = handLandmarker.detectForVideo(video, performance.now());
        updateWristFromLandmarks(res);
        lastVideoTime = video.currentTime;
      }

      // Update dragon body positions
      if (cursor.visible) {
        let targetX = cursor.x;
        let targetY = cursor.y;
        for (let i = 0; i < bodyPositions.length; i++) {
            const currentPos = bodyPositions[i];
            const dx = targetX - currentPos.x;
            const dy = targetY - currentPos.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            
            if (d > bodySpacing) {
                const angle = Math.atan2(dy, dx);
                const moveDist = d - bodySpacing;
                currentPos.x += Math.cos(angle) * moveDist * 0.55;
                currentPos.y += Math.sin(angle) * moveDist * 0.55;
            }
            targetX = currentPos.x;
            targetY = currentPos.y;
        }
      }
      
      // Update floating items and check for collision
      for (const item of items) {
        if (!item.active) continue;

        item.x += item.vx;
        item.y += item.vy;

        if (item.x <= 0 || item.x >= gameWidth - item.width) item.vx *= -1;
        if (item.y <= 0 || item.y >= gameHeight - item.height) item.vy *= -1;

        item.x = Math.max(0, Math.min(item.x, gameWidth - item.width));
        item.y = Math.max(0, Math.min(item.y, gameHeight - item.height));

        if (cursor.visible) {
          const cx = item.x + item.width / 2;
          const cy = item.y + item.height / 2;
          const dx = cursor.x - cx;
          const dy = cursor.y - cy;
          if ((dx*dx + dy*dy) < (HEAD_R + ITEM_R) ** 2) handleHit(item);
        }
      }

      // Update score popups
      popups = popups.filter(p => p.life > 0);
      for(const p of popups) {
        p.life -= 1 / 50; // Fades in about 0.8s (50 frames)
        p.y -= 1;
        p.alpha = p.life;
      }
    }

    // --- DRAW Function (All Canvas Rendering) ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Dragon Body
        if (cursor.visible && bodyPositions.length > 1) {
            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            // Glow
            ctx.strokeStyle = 'rgba(255, 150, 0, 0.3)';
            ctx.lineWidth = 45;
            ctx.beginPath();
            ctx.moveTo(bodyPositions[0].x, bodyPositions[0].y);
            for(let i = 1; i < bodyPositions.length; i++) {
                ctx.lineTo(bodyPositions[i].x, bodyPositions[i].y);
            }
            ctx.stroke();

            // Core body
            ctx.strokeStyle = '#d4b483';
            ctx.lineWidth = 18;
            ctx.beginPath();
            ctx.moveTo(bodyPositions[0].x, bodyPositions[0].y);
            for(let i = 1; i < bodyPositions.length; i++) {
                ctx.lineTo(bodyPositions[i].x, bodyPositions[i].y);
            }
            ctx.stroke();
        }

        // Draw Dragon Head (simplified version)
        if (cursor.visible) {
            const x = cursor.x;
            const y = cursor.y;
            // Snout
            ctx.fillStyle = '#d4b483';
            ctx.beginPath();
            ctx.ellipse(x, y + 15, 50, 25, 0, 0, 2 * Math.PI);
            ctx.fill();
            // Skull
            ctx.beginPath();
            ctx.ellipse(x, y - 10, 45, 35, 0, 0, 2 * Math.PI);
            ctx.fill();
            // Eyes
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#3e2723';
            ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(x - 20, y - 15, 10, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(x + 20, y - 15, 10, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.arc(x - 18, y - 15, 4, 0, 2 * Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(x + 22, y - 15, 4, 0, 2 * Math.PI); ctx.fill();
            // Fire/Incense glow
            ctx.fillStyle = 'rgba(255, 100, 0, 0.8)';
            ctx.beginPath(); ctx.arc(x, y - 50, 8, 0, 2 * Math.PI); ctx.fill();
            ctx.fillStyle = 'rgba(255, 200, 0, 0.9)';
            ctx.beginPath(); ctx.arc(x, y - 50, 4, 0, 2 * Math.PI); ctx.fill();
        }

        // Draw Floating Items
        ctx.font = '900 40px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.lineWidth = 3;

        for (const item of items) {
            if (!item.active) continue;
            
            const x = item.x + item.width / 2;
            const y = item.y + item.height / 2;

            ctx.fillStyle = '#fff9d1';
            ctx.beginPath();
            ctx.arc(x, y, ITEM_R, 0, 2 * Math.PI);
            ctx.fill();

            ctx.strokeStyle = item.kind === 'good' ? '#d32f2f' : '#555';
            ctx.stroke();
            
            ctx.fillStyle = item.kind === 'good' ? '#d32f2f' : '#333';
            ctx.fillText(item.text, x, y + 4); // +4 to vertically center CJK chars better
        }

        // Draw Score Popups
        ctx.font = '900 34px system-ui';
        for(const p of popups) {
            ctx.globalAlpha = p.alpha;
            ctx.fillStyle = p.color;
            ctx.fillText(p.text, p.x, p.y);
        }
        ctx.globalAlpha = 1.0;
    }

    // --- Main Game Loop ---
    function loop() {
      if (!isGameRunning) return;
      update();
      draw();
      requestAnimationFrame(loop);
    }

    // --- Game State Management ---
    function startGame() {
      errEl.style.display = 'none';
      bgVideo.play().catch(()=>{});

      score = 0;
      timeLeft = GAME_SECONDS;
      scoreEl.textContent = '0';
      timerEl.textContent = String(GAME_SECONDS);

      items = [];
      popups = [];
      isGameRunning = true;

      initDragonBody();
      spawnItems(6, 'good');
      spawnItems(4, 'bad');

      startScreen.style.display = 'none';
      gameOverScreen.style.display = 'none';

      if (!isMuted) sounds.bgm.play().catch(() => {});

      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        timeLeft -= 1;
        timerEl.textContent = String(timeLeft);
        if (timeLeft <= 0) endGame();
      }, 1000);

      loop();
    }

    function endGame() {
      isGameRunning = false;
      clearInterval(timerInterval);
      timerInterval = null;

      sounds.bgm.pause();
      sounds.bgm.currentTime = 0;
      playSound('end');

      finalScoreEl.textContent = String(score);
      gameOverScreen.style.display = 'flex';
    }

    // --- Event Listeners ---
    function resizeCanvas() {
        gameWidth = window.innerWidth;
        gameHeight = window.innerHeight;
        canvas.width = gameWidth;
        canvas.height = gameHeight;
    }
    window.addEventListener('resize', resizeCanvas);

    startBtn.addEventListener('click', async () => {
      startBtn.disabled = true;
      try {
        await initCamera();
        await initHandLandmarker();
        startGame();
      } catch (e) {
        errEl.style.display = 'block';
        errEl.textContent = "ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿæˆ–æ‰‹éƒ¨è¿½è¹¤æ¨¡å‹ã€‚è«‹ç¢ºèªç€è¦½å™¨æ¬Šé™ã€‚\n" + (e && e.message ? e.message : e);
      } finally {
        startBtn.disabled = false;
      }
    });

    restartBtn2.addEventListener('click', () => startGame());

    // --- Initial Setup ---
    resizeCanvas();

  </script>
</body>
</html>
