<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wrist Dragon Bubble Game</title>

  <!-- MediaPipe Tasks Vision (Hand Landmarker) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.mjs" crossorigin="anonymous"></script> <!-- [page:1] -->

  <style>
    :root {
      --hud-bg: rgba(0,0,0,0.55);
      --hud-fg: #fff;
      --accent: #ffd166;
    }
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--hud-fg);
      background: #111;
      overflow: hidden;
    }

    /* Stage */
    #stage {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: url("image_1.png") center/cover no-repeat fixed;
    }

    /* Camera + canvas overlay */
    #cameraWrap {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
    }
    #video {
      position: absolute;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* selfie mirror */
      opacity: 0.18; /* subtle camera background */
      filter: saturate(1.1) contrast(1.05);
    }
    #gameCanvas {
      position: absolute;
      width: 100%;
      height: 100%;
    }

    /* HUD */
    #hud {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;
    }
    .panel {
      background: var(--hud-bg);
      border: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(4px);
      padding: 10px 12px;
      border-radius: 12px;
      display: flex;
      gap: 14px;
      align-items: center;
      pointer-events: none;
    }
    .stat {
      display: grid;
      gap: 2px;
      line-height: 1.1;
    }
    .label {
      font-size: 12px;
      opacity: 0.85;
    }
    .value {
      font-size: 18px;
      font-weight: 700;
      color: var(--accent);
    }

    /* Start/Restart overlay */
    #overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(circle at center, rgba(0,0,0,0.35), rgba(0,0,0,0.78));
    }
    #card {
      width: min(560px, calc(100vw - 36px));
      background: rgba(0,0,0,0.65);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 18px;
      padding: 18px 18px 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.4);
    }
    #card h1 {
      margin: 0 0 8px;
      font-size: 20px;
      letter-spacing: 0.2px;
    }
    #card p {
      margin: 6px 0;
      opacity: 0.9;
      font-size: 14px;
      line-height: 1.35;
    }
    #controls {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    button {
      pointer-events: auto;
      cursor: pointer;
      border: 0;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 700;
      background: var(--accent);
      color: #111;
    }
    button.secondary {
      background: rgba(255,255,255,0.14);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.18);
    }
    #hint {
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.8;
    }
  </style>
</head>

<body>
  <div id="stage">
    <div id="cameraWrap">
      <video id="video" playsinline autoplay muted></video>
      <canvas id="gameCanvas"></canvas>
    </div>

    <div id="hud">
      <div class="panel">
        <div class="stat">
          <div class="label">Score</div>
          <div id="score" class="value">0</div>
        </div>
        <div class="stat">
          <div class="label">Time</div>
          <div id="time" class="value">60</div>
        </div>
      </div>

      <div class="panel">
        <div class="stat">
          <div class="label">Target</div>
          <div class="value" style="color:#7bf1a8;">Words +10</div>
        </div>
        <div class="stat">
          <div class="label">Avoid</div>
          <div class="value" style="color:#ff6b6b;">Emoji ‚àí5</div>
        </div>
      </div>
    </div>

    <div id="overlay">
      <div id="card">
        <h1>Tai Hang Fire Dragon ‚Äî Wrist Game</h1>
        <p>Raise your <b>right</b> hand and move your wrist to control the dragon.</p>
        <p>Hit word bubbles (+10). Avoid emoji bubbles (‚àí5).</p>
        <p>Tip: If your motion feels reversed, keep the ‚ÄúMirror camera‚Äù option enabled (default).</p>
        <div id="controls">
          <button id="startBtn">Start (unlock audio + camera)</button>
          <button id="mirrorBtn" class="secondary">Mirror camera: ON</button>
          <button id="restartBtn" class="secondary" style="display:none;">Play again</button>
        </div>
        <div id="hint">Audio with sound usually requires a user click/tap before it can play. [page:0]</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.mjs";

    // -----------------------------
    // Game configuration
    // -----------------------------
    const EMOJIS = ['‚öΩ', 'üçî', 'üéß', 'üßä', 'üßß', 'üßº', 'üç∫', 'üí°', 'üìé', 'üßΩ', 'üßØ'];
    const WORDS  = ['Á¶è', 'Êò•', 'Ë≤°', 'ÂÆâ', 'Êó∫', 'Âêâ', 'Á••', 'Ë≥Ä', 'È¶¨', 'Âπ¥'];

    const GAME_SECONDS = 60;
    const SPAWN_EVERY_MS = 650;
    const BUBBLE_LIFETIME_MS = 5200;

    const SCORE_WORD = +10;
    const SCORE_EMOJI = -5;

    const DRAGON_RADIUS = 36;      // collision radius
    const BUBBLE_RADIUS = 28;      // collision radius
    const SMOOTHING = 0.22;        // wrist smoothing

    // -----------------------------
    // DOM
    // -----------------------------
    const video = document.getElementById("video");
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const overlay = document.getElementById("overlay");
    const startBtn = document.getElementById("startBtn");
    const restartBtn = document.getElementById("restartBtn");
    const mirrorBtn = document.getElementById("mirrorBtn");

    const scoreEl = document.getElementById("score");
    const timeEl = document.getElementById("time");

    // -----------------------------
    // Audio
    // -----------------------------
    const sfxCrunch  = new Audio("Crunch.mp3");
    const sfxCollect = new Audio("Collect.mp3");
    const bgm        = new Audio("bgm.mp3");
    const endMusic   = new Audio("end.mp3");

    bgm.loop = true;
    bgm.volume = 0.45;
    sfxCrunch.volume = 0.9;
    sfxCollect.volume = 0.9;
    endMusic.volume = 0.7;

    function safePlay(audio) {
      const p = audio.play();
      if (p && typeof p.catch === "function") p.catch(() => {});
    }

    // -----------------------------
    // MediaPipe Hand Landmarker
    // -----------------------------
    let handLandmarker = null;
    let lastVideoTime = -1;

    async function initHandLandmarker() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
      ); // [page:1]
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: "hand_landmarker.task" },
        runningMode: "VIDEO",
        numHands: 2,
        minHandDetectionConfidence: 0.5,
        minHandPresenceConfidence: 0.5,
        minTrackingConfidence: 0.5,
      }); // [page:1]
    }

    // -----------------------------
    // Camera
    // -----------------------------
    async function initCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user" },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
    }

    // -----------------------------
    // Game state
    // -----------------------------
    let mirror = true;

    let running = false;
    let score = 0;
    let timeLeft = GAME_SECONDS;

    let bubbles = [];
    let spawnTimer = 0;
    let gameTimerInterval = null;

    // Dragon position (screen pixels)
    let dragonX = 0.5;
    let dragonY = 0.65;
    let dragonPx = { x: 0, y: 0 };
    let dragonVel = { x: 0, y: 0 };
    let hasWrist = false;

    function resize() {
      canvas.width = Math.floor(window.innerWidth * devicePixelRatio);
      canvas.height = Math.floor(window.innerHeight * devicePixelRatio);
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }
    window.addEventListener("resize", resize);

    // -----------------------------
    // Bubble helpers
    // -----------------------------
    function rand(min, max) { return Math.random() * (max - min) + min; }
    function pick(arr) { return arr[(Math.random() * arr.length) | 0]; }

    function spawnBubble() {
      const isEmoji = Math.random() < 0.55;
      const text = isEmoji ? pick(EMOJIS) : pick(WORDS);

      const w = window.innerWidth;
      const h = window.innerHeight;

      bubbles.push({
        id: crypto.randomUUID(),
        kind: isEmoji ? "emoji" : "word",
        text,
        x: rand(80, w - 80),
        y: rand(110, h - 80),
        r: BUBBLE_RADIUS,
        bornAt: performance.now(),
        wobble: rand(0, Math.PI * 2),
      });
    }

    function resetGame() {
      score = 0;
      timeLeft = GAME_SECONDS;
      bubbles = [];
      spawnTimer = 0;
      scoreEl.textContent = String(score);
      timeEl.textContent = String(timeLeft);
      dragonX = 0.5;
      dragonY = 0.65;
      hasWrist = false;
    }

    function endGame() {
      running = false;
      clearInterval(gameTimerInterval);
      gameTimerInterval = null;

      bgm.pause();
      bgm.currentTime = 0;
      safePlay(endMusic);

      overlay.style.display = "grid";
      startBtn.style.display = "none";
      restartBtn.style.display = "inline-block";
    }

    // -----------------------------
    // Collision detection
    // -----------------------------
    function hitTestCircle(ax, ay, ar, bx, by, br) {
      const dx = ax - bx;
      const dy = ay - by;
      const rr = ar + br;
      return (dx * dx + dy * dy) <= (rr * rr);
    }

    function handleCollisions() {
      const px = dragonPx.x;
      const py = dragonPx.y;

      for (let i = bubbles.length - 1; i >= 0; i--) {
        const b = bubbles[i];
        if (hitTestCircle(px, py, DRAGON_RADIUS, b.x, b.y, b.r)) {
          if (b.kind === "emoji") {
            score += SCORE_EMOJI;
            safePlay(sfxCrunch);
          } else {
            score += SCORE_WORD;
            safePlay(sfxCollect);
          }
          scoreEl.textContent = String(score);
          bubbles.splice(i, 1);
        }
      }
    }

    // -----------------------------
    // Dragon drawing (coded)
    // -----------------------------
    function drawDragon(x, y, t) {
      ctx.save();
      ctx.translate(x, y);

      // Motion-driven angle
      const angle = Math.atan2(dragonVel.y, dragonVel.x) || 0;
      ctx.rotate(angle * 0.25);

      // Glow
      const g = ctx.createRadialGradient(0, 0, 6, 0, 0, 70);
      g.addColorStop(0, "rgba(255,210,80,0.65)");
      g.addColorStop(0.45, "rgba(255,95,48,0.28)");
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(0, 0, 70, 0, Math.PI * 2);
      ctx.fill();

      // Tail + body: a ‚Äúfire ribbon‚Äù curve
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      const wig = Math.sin(t * 0.012) * 10;
      const len = 140;

      ctx.strokeStyle = "rgba(255, 160, 60, 0.9)";
      ctx.lineWidth = 16;
      ctx.beginPath();
      ctx.moveTo(-len, wig);
      ctx.quadraticCurveTo(-60, -25 - wig*0.2, -18, 0);
      ctx.quadraticCurveTo(18, 18 + wig*0.25, 42, 0);
      ctx.stroke();

      ctx.strokeStyle = "rgba(255, 70, 30, 0.85)";
      ctx.lineWidth = 9;
      ctx.beginPath();
      ctx.moveTo(-len + 10, wig + 6);
      ctx.quadraticCurveTo(-56, -18 - wig*0.1, -18, 0);
      ctx.quadraticCurveTo(18, 16 + wig*0.15, 42, 0);
      ctx.stroke();

      // Head
      ctx.fillStyle = "rgba(255, 220, 120, 0.92)";
      ctx.strokeStyle = "rgba(140, 30, 15, 0.55)";
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.ellipse(52, 0, 20, 16, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Snout / flame mouth
      ctx.fillStyle = "rgba(255, 120, 40, 0.9)";
      ctx.beginPath();
      ctx.moveTo(66, -2);
      ctx.quadraticCurveTo(82, 0, 66, 6);
      ctx.quadraticCurveTo(70, 2, 66, -2);
      ctx.fill();

      // Eye
      ctx.fillStyle = "rgba(30, 10, 8, 0.85)";
      ctx.beginPath();
      ctx.arc(54, -5, 2.8, 0, Math.PI * 2);
      ctx.fill();

      // Whiskers / bristles (inspired by fire-dragon straw texture)
      ctx.strokeStyle = "rgba(255, 235, 190, 0.75)";
      ctx.lineWidth = 2;
      for (let i = 0; i < 10; i++) {
        const a = -0.9 + i * 0.18 + Math.sin(t*0.01 + i) * 0.02;
        const L = 28 + (i % 3) * 8;
        ctx.beginPath();
        ctx.moveTo(50, 0);
        ctx.lineTo(50 + Math.cos(a) * L, Math.sin(a) * L);
        ctx.stroke();
      }

      // Horns
      ctx.strokeStyle = "rgba(255, 245, 220, 0.8)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(44, -10);
      ctx.lineTo(36, -26);
      ctx.moveTo(52, -12);
      ctx.lineTo(50, -30);
      ctx.stroke();

      ctx.restore();
    }

    // -----------------------------
    // Bubble drawing
    // -----------------------------
    function drawBubble(b, t) {
      const wob = Math.sin(t * 0.004 + b.wobble) * 3;
      const x = b.x;
      const y = b.y + wob;

      ctx.save();
      ctx.translate(x, y);

      // Bubble background
      const fill = (b.kind === "emoji")
        ? "rgba(255, 90, 90, 0.22)"
        : "rgba(80, 255, 170, 0.18)";
      const stroke = (b.kind === "emoji")
        ? "rgba(255, 90, 90, 0.7)"
        : "rgba(80, 255, 170, 0.75)";

      ctx.fillStyle = fill;
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.arc(0, 0, b.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Text
      ctx.font = (b.kind === "word") ? "24px system-ui" : "26px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.fillText(b.text, 0, 1);

      ctx.restore();
    }

    // -----------------------------
    // Tracking: get right wrist
    // -----------------------------
    function updateWristFromLandmarks(result) {
      hasWrist = false;
      if (!result || !result.landmarks || result.landmarks.length === 0) return;

      // Choose right hand if present (MediaPipe provides handedness categories) [page:1]
      let idx = 0;
      if (result.handednesses && result.handednesses.length) {
        const rightIndex = result.handednesses.findIndex(h =>
          h && h[0] && String(h[0].categoryName).toLowerCase() === "right"
        );
        if (rightIndex >= 0) idx = rightIndex;
      }

      const lm = result.landmarks[idx];
      if (!lm || !lm[0]) return;

      // Landmark 0 is wrist in MediaPipe Hands/HandLandmarker [page:1]
      let x = lm[0].x; // normalized 0..1
      let y = lm[0].y;

      // Mirror compensation:
      // - video is mirrored visually, so to keep control matching the mirrored view, flip x.
      if (mirror) x = 1 - x;

      // Smooth in normalized space
      dragonX = dragonX + (x - dragonX) * SMOOTHING;
      dragonY = dragonY + (y - dragonY) * SMOOTHING;
      hasWrist = true;
    }

    // -----------------------------
    // Main loop
    // -----------------------------
    function tick(t) {
      if (!running) return;

      // Update detection if new video frame
      if (video.readyState >= 2 && handLandmarker) {
        if (video.currentTime !== lastVideoTime) {
          const res = handLandmarker.detectForVideo(video, performance.now());
          updateWristFromLandmarks(res);
          lastVideoTime = video.currentTime;
        }
      }

      // Resize-safe pixel coords
      const w = window.innerWidth;
      const h = window.innerHeight;

      const targetPx = {
        x: dragonX * w,
        y: dragonY * h
      };

      // Velocity for ‚Äúheading‚Äù
      dragonVel.x = targetPx.x - dragonPx.x;
      dragonVel.y = targetPx.y - dragonPx.y;

      // Move dragon
      dragonPx.x += dragonVel.x * 0.35;
      dragonPx.y += dragonVel.y * 0.35;

      // Spawn bubbles
      spawnTimer += 16.7;
      if (spawnTimer >= SPAWN_EVERY_MS) {
        spawnTimer = 0;
        spawnBubble();
      }

      // Expire old bubbles
      const now = performance.now();
      bubbles = bubbles.filter(b => (now - b.bornAt) < BUBBLE_LIFETIME_MS);

      // Collisions
      handleCollisions();

      // Draw
      ctx.clearRect(0, 0, w, h);

      // If no wrist yet, show a hint marker
      if (!hasWrist) {
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.75)";
        ctx.font = "14px system-ui";
        ctx.fillText("Show your right hand to the camera‚Ä¶", 16, h - 18);
        ctx.restore();
      }

      for (const b of bubbles) drawBubble(b, t);
      drawDragon(dragonPx.x, dragonPx.y, t);

      requestAnimationFrame(tick);
    }

    // -----------------------------
    // Start / Restart
    // -----------------------------
    async function startGame() {
      overlay.style.display = "none";
      restartBtn.style.display = "none";
      startBtn.style.display = "inline-block";

      resetGame();
      endMusic.pause();
      endMusic.currentTime = 0;

      // Start BGM after user gesture (helps pass autoplay restrictions) [page:0]
      safePlay(bgm);

      running = true;
      gameTimerInterval = setInterval(() => {
        timeLeft -= 1;
        timeEl.textContent = String(timeLeft);
        if (timeLeft <= 0) endGame();
      }, 1000);

      requestAnimationFrame(tick);
    }

    mirrorBtn.addEventListener("click", () => {
      mirror = !mirror;
      mirrorBtn.textContent = `Mirror camera: ${mirror ? "ON" : "OFF"}`;
      video.style.transform = mirror ? "scaleX(-1)" : "scaleX(1)";
    });

    startBtn.addEventListener("click", async () => {
      startBtn.disabled = true;
      startBtn.textContent = "Starting‚Ä¶";

      try {
        resize();
        await initCamera();
        await initHandLandmarker();
        await startGame();
      } catch (e) {
        alert("Failed to start. Please allow camera access and make sure hand_landmarker.task is present.");
        console.error(e);
        overlay.style.display = "grid";
      } finally {
        startBtn.disabled = false;
        startBtn.textContent = "Start (unlock audio + camera)";
      }
    });

    restartBtn.addEventListener("click", async () => {
      overlay.style.display = "none";
      await startGame();
    });

    // Initial sizing
    resize();
  </script>
</body>
</html>
