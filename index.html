<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Hiro Marker AR Demo + ç¢°æ’èˆ‡åˆ†æ•¸ï¼ˆç›¸æ©Ÿåƒ…é¡åƒï¼Œä¿®æ­£æŠ•å°„ï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <!-- AR.js for A-Frame -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; }
    body { font-family: system-ui, -apple-system, "Helvetica Neue", Arial, sans-serif; }

    .overlay {
      position: fixed;
      top: 0; left: 0; right: 0;
      display: flex; justify-content: space-between; align-items: center;
      padding: 12px 16px;
      background: linear-gradient(180deg, rgba(0,0,0,0.65), rgba(0,0,0,0));
      color: #fff; z-index: 30; pointer-events: none;
      font-size: 14px;
    }
    .hint {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      padding: 10px 14px;
      background: linear-gradient(0deg, rgba(0,0,0,0.7), rgba(0,0,0,0));
      color: #fff; z-index: 30; text-align: center;
      font-size: 13px; pointer-events: none;
    }
    .badge {
      background: rgba(255,255,255,0.12);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      pointer-events: auto;
    }
    .link { color: #9ad6ff; text-decoration: underline; pointer-events: auto; }
    .score { pointer-events: none; font-weight: 600; }

    .controls {
      display: flex; gap: 8px; align-items: center;
      pointer-events: auto;
    }
    .btn {
      background: rgba(255,255,255,0.12);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 13px;
      cursor: pointer;
      backdrop-filter: blur(4px);
    }
    .btn.active {
      background: rgba(0, 150, 255, 0.25);
      border-color: rgba(0, 150, 255, 0.6);
    }

    /* ç›®æ¨™å®¹å™¨ï¼šä¸é¡åƒï¼Œå›ºå®šåœ¨ç•«é¢ä¸Šæ–¹ */
    .targets-layer {
      position: fixed;
      inset: 0;
      z-index: 20;
      pointer-events: none;
      transform-origin: center;
    }

    .target {
      position: absolute;
      transform: translate(-50%, -50%);
      font-size: 28px;
      line-height: 1;
      user-select: none;
      filter: drop-shadow(0 1px 0 rgba(0,0,0,0.3))
              drop-shadow(0 2px 4px rgba(0,0,0,0.25));
      transition: transform 0.08s ease-out;
    }
    .target.first { color: #00E676; }
    .target.second { color: #FF5252; }

    /* åŒ…è£¹ A-Frame ç•«å¸ƒä»¥ä¾¿å¥—ç”¨é¡åƒï¼ˆåªé¡åƒç›¸æ©Ÿç•«é¢èˆ‡ 3Dï¼‰ */
    .scene-wrap {
      position: fixed;
      inset: 0;
      z-index: 10; /* åœ¨ targets-layer ä¹‹ä¸‹ */
      transform-origin: center;
    }
    .scene-wrap.mirrored {
      transform: scaleX(-1);
    }

    @media (max-width: 640px) {
      .overlay { font-size: 13px; padding: 10px 12px; }
      .hint { font-size: 12px; padding: 8px 12px; }
      .target { font-size: 24px; }
    }
  </style>
</head>
<body>
  <div class="overlay">
    <div class="badge">Hiro Marker AR</div>
    <div class="controls">
      <div class="score" id="score">åˆ†æ•¸ï¼š0</div>
      <button id="mirrorBtn" class="btn" type="button">é¡åƒï¼šé—œ</button>
    </div>
  </div>

  <!-- ä¸é¡åƒçš„ 2D ç›®æ¨™å±¤ -->
  <div class="targets-layer" id="targetsLayer"></div>

  <div class="hint">
    å°‡ Hiro æ¨™è¨˜ç½®æ–¼é¡é ­å‰æ–¹ï¼Œ3D ç‰©ä»¶æœƒå‡ºç¾åœ¨æ¨™è¨˜ä¸Šã€‚<br/>
    æ²’æœ‰æ¨™è¨˜ï¼Ÿå¯åˆ—å°ï¼š<a class="link" href="https://raw.githubusercontent.com/AR-js-org/AR.js/master/aframe/examples/marker-training/examples/pattern-files/pattern-hiro.png" target="_blank" rel="noopener">ä¸‹è¼‰ Hiro åœ–</a><br/>
    æç¤ºï¼šç§»å‹•æ¨™è¨˜å»ç¢°è§¸è¢å¹•ä¸­çš„å­—å…ƒä¾†åŠ æ¸›åˆ†ï¼å³ä¸Šè§’ã€Œé¡åƒã€åªå½±éŸ¿ç›¸æ©Ÿç•«é¢ã€‚
  </div>

  <!-- åªåœ¨é€™å€‹å®¹å™¨ä¸Šåšé¡åƒ -->
  <div class="scene-wrap" id="sceneWrap">
    <a-scene
      vr-mode-ui="enabled: false"
      embedded
      renderer="logarithmicDepthBuffer: true; antialias: true;"
      arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono; maxDetectionRate: 30;"
    >
      <!-- å…‰æº -->
      <a-entity light="type: ambient; color: #cccccc"></a-entity>
      <a-entity light="type: directional; color: #ffffff; intensity: 0.8" position="1 1 0.5"></a-entity>

      <!-- Hiro æ¨™è¨˜ï¼ˆç©å®¶ï¼‰ -->
      <a-marker preset="hiro" id="marker">
        <a-box id="player"
               position="0 0.5 0"
               depth="1" height="1" width="1"
               color="#4FC3F7"
               animation="property: rotation; to: 0 360 0; loop: true; dur: 4000; easing: linear">
        </a-box>
        <a-cylinder position="0 0 0" radius="0.35" height="0.1" color="#FFC107"></a-cylinder>
      </a-marker>

      <!-- ç›¸æ©Ÿ -->
      <a-entity camera id="camera"></a-entity>

      <!-- 3D ç¢°æ’é»å®¹å™¨ -->
      <a-entity id="collidersRoot"></a-entity>
    </a-scene>
  </div>

  <script>
    const FIRST_SET = ['ç¦', 'æ˜¥', 'è²¡', 'å®‰', 'æ—º', 'å‰', 'ç¥¥', 'è³€', 'é¾', 'å¹´'];
    const SECOND_SET = ['âš½', 'ğŸ”', 'ğŸ§', 'ğŸ§Š', 'ğŸ§¼', 'ğŸº', 'ğŸ’¡', 'ğŸ“', 'ğŸ§½', 'ğŸ§¯'];

    const COUNT_PER_SET = 10;
    const SPEED_MIN = 60;
    const SPEED_MAX = 160;

    // 3D ç¢°æ’ç”¨åƒæ•¸
    const PLANE_DISTANCE = 2;     // ç›¸æ©Ÿå‰æ–¹ 2 å…¬å°º
    const COLLIDE_RADIUS = 0.75;  // èˆ‡ç©å®¶æ–¹å¡Šçš„ç¢°æ’åŠå¾‘
    const SCORE_HIT_FIRST = 15;
    const SCORE_HIT_SECOND = -5;
    const HIT_COOLDOWN_MS = 600;

    const scene = document.querySelector('a-scene');
    const cameraEl = document.getElementById('camera');
    const playerEl = document.getElementById('player');
    const collidersRoot = document.getElementById('collidersRoot');

    const targetsLayer = document.getElementById('targetsLayer');
    const scoreEl = document.getElementById('score');

    const sceneWrap = document.getElementById('sceneWrap');
    const mirrorBtn = document.getElementById('mirrorBtn');

    let score = 0;
    let mirrored = false; // é¡åƒé–‹é—œï¼ˆåƒ…å½±éŸ¿ç›¸æ©Ÿç•«é¢èˆ‡ 3Dï¼‰
    let aframeCanvas = null; // å–å¾— A-Frame å¯¦éš› canvas
    let canvasRect = null;

    function setScore(v){ score=v; scoreEl.textContent = `åˆ†æ•¸ï¼š${score}`; }

    // åˆ‡æ›é¡åƒè¦–è¦ºï¼ˆåƒ… sceneWrapï¼‰
    function setMirrored(on) {
      mirrored = on;
      mirrorBtn.textContent = `é¡åƒï¼š${mirrored ? 'é–‹' : 'é—œ'}`;
      mirrorBtn.classList.toggle('active', mirrored);
      sceneWrap.classList.toggle('mirrored', mirrored);
    }

    mirrorBtn.addEventListener('click', () => setMirrored(!mirrored));

    // å–å¾— A-Frame canvas èˆ‡å…¶ rect
    function cacheCanvasRect() {
      aframeCanvas = scene?.canvas || document.querySelector('canvas.a-canvas');
      if (aframeCanvas) {
        canvasRect = aframeCanvas.getBoundingClientRect();
      }
    }

    // å°‡è¢å¹•åº§æ¨™ï¼ˆç›¸å°è¦–çª—å·¦ä¸Šï¼‰è½‰æ›æˆã€Œå¯¦éš› WebGL ç•«å¸ƒçš„ NDCã€
    function screenPosToCanvasNDC(sx, sy) {
      if (!aframeCanvas || !canvasRect) return null;
      // å…ˆæ›æˆåœ¨ canvas å…§éƒ¨çš„åƒç´ åº§æ¨™
      const cx = sx - canvasRect.left;
      const cy = sy - canvasRect.top;

      // é¡åƒæ™‚ï¼Œè¦–è¦ºç¿»è½‰çš„æ˜¯ canvasï¼Œæ‰€ä»¥è¦åœ¨ canvas åº§æ¨™ç³»åš X ç¿»è½‰
      const adjCx = mirrored ? (canvasRect.width - cx) : cx;

      // è½‰ NDC (-1..1)
      const ndcX = (adjCx / canvasRect.width) * 2 - 1;
      const ndcY = -((cy / canvasRect.height) * 2 - 1); // Y è»¸å‘ä¸‹ç‚ºæ­£ -> NDC å‘ä¸Šç‚ºæ­£
      return { ndcX, ndcY };
    }

    // ä½¿ç”¨ canvas NDC æŠ•å°„åˆ°ç›¸æ©Ÿå‰æ–¹å›ºå®šè·é›¢
    function screenToWorldAtDistance(sx, sy, dist) {
      const threeCam = cameraEl.getObject3D('camera');
      if (!threeCam) return null;
      const ndc = screenPosToCanvasNDC(sx, sy);
      if (!ndc) return null;

      const vecNDC = new THREE.Vector3(ndc.ndcX, ndc.ndcY, 0.5);
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(vecNDC, threeCam);
      const origin = raycaster.ray.origin.clone();
      const dir = raycaster.ray.direction.clone().normalize();
      return origin.add(dir.multiplyScalar(dist));
    }

    function createTarget(char, type) {
      // 1) ç•«é¢å…ƒç´ ï¼ˆä¸é¡åƒï¼‰
      const span = document.createElement('span');
      span.className = `target ${type === 'first' ? 'first' : 'second'}`;
      span.textContent = char;
      targetsLayer.appendChild(span);

      // éš¨æ©Ÿåˆå§‹ä½ç½®èˆ‡é€Ÿåº¦
      const margin = 28;
      const st = {
        type,
        sx: Math.random() * (window.innerWidth - margin*2) + margin,
        sy: Math.random() * (window.innerHeight - margin*2) + margin,
        vx: (Math.random()*2-1) * (SPEED_MIN + Math.random()*(SPEED_MAX-SPEED_MIN)),
        vy: (Math.random()*2-1) * (SPEED_MIN + Math.random()*(SPEED_MAX-SPEED_MIN)),
        lastHitAt: 0
      };
      span.__state = st;

      // 2) å°æ‡‰ 3D ç¢°æ’é»ï¼ˆä¸å¯è¦‹å°çƒï¼‰
      const col = document.createElement('a-entity');
      col.setAttribute('geometry', 'primitive: sphere; radius: 0.01');
      col.setAttribute('material', 'visible: false; color: #fff; opacity: 0');
      collidersRoot.appendChild(col);
      span.__collider = col;

      // åˆæ¬¡å®šä½ DOM
      span.style.left = `${st.sx}px`;
      span.style.top = `${st.sy}px`;
      return span;
    }

    const targets = [];
    function spawnAllTargets() {
      for (let i=0; i<COUNT_PER_SET; i++) {
        targets.push(createTarget(FIRST_SET[i % FIRST_SET.length], 'first'));
      }
      for (let i=0; i<COUNT_PER_SET; i++) {
        targets.push(createTarget(SECOND_SET[i % SECOND_SET.length], 'second'));
      }
    }

    function hitFeedback(span) {
      span.style.transform = 'translate(-50%, -50%) scale(1.3)';
      setTimeout(() => {
        span.style.transform = 'translate(-50%, -50%) scale(1)';
      }, 120);
    }

    let lastT = performance.now();
    function loop() {
      const now = performance.now();
      const dt = (now - lastT) / 1000;
      lastT = now;

      const margin = 20;
      const minX = margin, maxX = window.innerWidth - margin;
      const minY = margin, maxY = window.innerHeight - margin;

      // æ›´æ–°æ¯å€‹ç›®æ¨™ä½ç½®ï¼ˆè¢å¹• 2Dï¼‰èˆ‡ 3D ç¢°æ’é»
      for (const span of targets) {
        const st = span.__state;
        if (!st) continue;

        st.sx += st.vx * dt;
        st.sy += st.vy * dt;

        // é‚Šç•Œåå½ˆ
        if (st.sx < minX) { st.sx = minX; st.vx = Math.abs(st.vx); }
        if (st.sx > maxX) { st.sx = maxX; st.vx = -Math.abs(st.vx); }
        if (st.sy < minY) { st.sy = minY; st.vy = Math.abs(st.vy); }
        if (st.sy > maxY) { st.sy = maxY; st.vy = -Math.abs(st.vy); }

        // DOM ä½ç½®
        span.style.left = `${st.sx}px`;
        span.style.top = `${st.sy}px`;

        // æ›´æ–° 3D ç¢°æ’é»ä½ç½®ï¼ˆç”¨ canvas NDC + é¡åƒä¿®æ­£ï¼‰
        const world = screenToWorldAtDistance(st.sx, st.sy, PLANE_DISTANCE);
        if (world) {
          span.__collider.object3D.position.copy(world);
        }
      }

      // ç©å®¶ä¸–ç•Œä½ç½®
      const playerWorld = new THREE.Vector3();
      playerEl.object3D.getWorldPosition(playerWorld);

      // ç¢°æ’èˆ‡è¨ˆåˆ†
      for (const span of targets) {
        const st = span.__state;
        if (!st) continue;
        const col = span.__collider;
        const pos = new THREE.Vector3();
        col.object3D.getWorldPosition(pos);
        const dist = playerWorld.distanceTo(pos);
        if (dist <= COLLIDE_RADIUS) {
          if (now - st.lastHitAt > HIT_COOLDOWN_MS) {
            st.lastHitAt = now;
            score += (st.type === 'first' ? SCORE_HIT_FIRST : SCORE_HIT_SECOND);
            setScore(score);
            hitFeedback(span);
          }
        }
      }

      requestAnimationFrame(loop);
    }

    function start() {
      cacheCanvasRect();           // æŠ“ canvas èˆ‡ rect
      spawnAllTargets();
      lastT = performance.now();
      requestAnimationFrame(loop);
    }

    // ç­‰ scene è¼‰å…¥å¾Œå†å•Ÿå‹•ï¼Œç¢ºä¿ scene.canvas å¯å–å¾—
    if (document.readyState === 'complete') {
      if (scene.hasLoaded) start();
      else scene.addEventListener('loaded', start);
    } else {
      window.addEventListener('load', () => {
        if (scene.hasLoaded) start();
        else scene.addEventListener('loaded', start);
      });
    }

    // ä»»ä½•å¯èƒ½è®Šå‹• canvas å°ºå¯¸/ä½ç½®çš„äº‹ä»¶ï¼Œéƒ½æ›´æ–° rect
    const recalcCanvasRect = () => {
      cacheCanvasRect();
    };
    window.addEventListener('resize', () => {
      const margin = 24;
      for (const span of targets) {
        const st = span.__state;
        st.sx = Math.min(Math.max(st.sx, margin), window.innerWidth - margin);
        st.sy = Math.min(Math.max(st.sy, margin), window.innerHeight - margin);
        span.style.left = `${st.sx}px`;
        span.style.top = `${st.sy}px`;
      }
      recalcCanvasRect();
    });

    // æœ‰äº›è£ç½®æœƒåœ¨æ–¹å‘æ”¹è®Šã€éµç›¤å½ˆå‡ºã€è¦–å£èª¿æ•´æ™‚å½±éŸ¿ rectï¼š
    window.addEventListener('orientationchange', recalcCanvasRect);
    window.addEventListener('scroll', recalcCanvasRect);
    window.addEventListener('visibilitychange', recalcCanvasRect);

    // A-Frame åœ¨æŸäº›æƒ…æ³ä¸‹æœƒé‡å»º canvasï¼Œå› æ­¤ä¹Ÿç›£è½ scene çš„ render-start
    scene.addEventListener('renderstart', recalcCanvasRect);
  </script>
</body>
</html>
