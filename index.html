<!DOCTYPE html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>å¤§å‘èˆç«é¾ AR å°éŠæˆ²ï¼ˆå–®å¼µè²¼åœ–ãƒ»æ—‹è½‰ç„¡æ“ºå‹•ï¼‰</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; background: #000; color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans HK", "Noto Sans CJK", "PingFang HK", "Heiti TC", Arial, sans-serif;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      touch-action: manipulation;
    }
    .wrap { position: relative; width: 100%; height: 100%; background: #000; }
    video#cam {
      position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover;
      transform: scaleX(-1); background: #000;
    }
    img#bg { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; pointer-events: none; opacity: 0.2; mix-blend-mode: lighten; }
    canvas#game { position: absolute; inset: 0; width: 100%; height: 100%; touch-action: none; pointer-events: none; }
    .ui {
      position: absolute; left: 0; right: 0; top: 0; display: flex; align-items: center; justify-content: space-between;
      padding: 10px 12px; gap: 8px; background: linear-gradient(180deg, rgba(0,0,0,0.5), rgba(0,0,0,0)); user-select: none; z-index: 10;
    }
    .btn { background: #e11d48; border: none; color: #fff; border-radius: 10px; padding: 10px 14px; font-weight: 700; letter-spacing: 0.5px; box-shadow: 0 4px 12px rgba(225,29,72,0.35); }
    .btn.secondary { background:#334155; box-shadow: 0 4px 12px rgba(15,23,42,0.35); }
    .btn:disabled { opacity: 0.6; }
    .btn:active { transform: translateY(1px); }
    .hud { display: flex; gap: 10px; align-items: center; font-weight: 700; text-shadow: 0 2px 6px rgba(0,0,0,0.6); flex-wrap: wrap; }
    .chip { background: rgba(0,0,0,0.45); border: 1px solid rgba(255,255,255,0.2); border-radius: 999px; padding: 6px 10px; font-size: 14px; }
    .bar {
      position: absolute; left: 12px; right: 12px; bottom: 12px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center;
      background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 10px; z-index: 10;
    }
    .range-group { display: flex; align-items: center; gap: 8px; color: #ddd; font-size: 12px; }
    input[type="range"] { width: 120px; }
    .hint {
      position: absolute; left: 0; right: 0; top: 50%; transform: translateY(-50%);
      text-align: center; padding: 0 16px; color: #ffd166; font-weight: 700; text-shadow: 0 2px 10px rgba(0,0,0,0.7); z-index: 5;
    }
    .ok { color: #22c55e; }
    .bad { color: #f97316; }
    .top-right { position: absolute; top: 10px; right: 8px; display: flex; gap: 8px; z-index: 11; }
    .mini { padding: 8px 10px; font-weight: 600; font-size: 12px; border-radius: 8px; background: rgba(0,0,0,0.45); border: 1px solid rgba(255,255,255,0.2); color: #fff; }
  </style>
</head>
<body>
  <div class="wrap">
    <video id="cam" playsinline muted autoplay></video>
    <img id="bg" alt="èƒŒæ™¯" src="" />
    <canvas id="game"></canvas>

    <div class="ui">
      <button id="startBtn" class="btn">é–‹å§‹</button>
      <div class="hud">
        <div class="chip">åˆ†æ•¸ï¼š<span id="score">0</span></div>
        <div class="chip">Comboï¼š<span id="combo">0</span></div>
        <div class="chip">æ™‚é–“ï¼š<span id="time">60</span>s</div>
      </div>
      <div class="top-right">
        <button id="toggleFacing" class="mini">åˆ‡æ›é¡é ­</button>
        <button id="toggleMirror" class="mini">é¡åƒï¼šé–‹</button>
        <button id="fullscreenBtn" class="mini">å…¨å±</button>
        <button id="resetBtn" class="btn secondary">é‡ç½®</button>
      </div>
    </div>

    <div class="bar">
      <div class="range-group">
        Hmin <input id="hMin" type="range" min="0" max="360" value="330">
        Hmax <input id="hMax" type="range" min="0" max="360" value="20">
      </div>
      <div class="range-group">
        Smin <input id="sMin" type="range" min="0" max="100" value="50">
        Vmin <input id="vMin" type="range" min="0" max="100" value="40">
      </div>
      <div class="range-group">
        éˆæ•åº¦ <input id="sens" type="range" min="0" max="300" value="80">
      </div>
      <div class="range-group">
        ç›®æ¨™å¯†åº¦ <input id="density" type="range" min="1" max="10" value="4">
      </div>
      <div class="range-group">
        é€Ÿåº¦ <input id="speed" type="range" min="1" max="10" value="5">
      </div>
    </div>

    <div id="hint" class="hint">æŒ‰ã€Œé–‹å§‹ã€å…è¨±ç›¸æ©Ÿæ¬Šé™ã€‚è«‹ä»¥ç´…è‰²ç‰©ä»¶åœ¨é¡é ­å‰æ®å‹•ã€‚</div>
  </div>

  <script>
    // ========= DOM =========
    const video = document.getElementById('cam');
    const bgImg = document.getElementById('bg');
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: true });

    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const toggleFacingBtn = document.getElementById('toggleFacing');
    const toggleMirrorBtn = document.getElementById('toggleMirror');
    const fullscreenBtn = document.getElementById('fullscreenBtn');

    const scoreEl = document.getElementById('score');
    const comboEl = document.getElementById('combo');
    const timeEl = document.getElementById('time');
    const hintEl = document.getElementById('hint');

    const hMinEl = document.getElementById('hMin');
    const hMaxEl = document.getElementById('hMax');
    const sMinEl = document.getElementById('sMin');
    const vMinEl = document.getElementById('vMin');
    const sensEl = document.getElementById('sens');
    const densEl = document.getElementById('density');
    const speedEl = document.getElementById('speed');

    // ========= ç‹€æ…‹ =========
    let running = false;
    let gameOver = false;
    let W = 0, H = 0, dpr = 1;

    let score = 0, combo = 0, timeLeft = 60;
    let timerId = null;

    let centroid = { x: 0, y: 0 };
    let direction = { x: 1, y: 0 };
    let smoothing = 0.28;

    let useEnvironment = true;
    let mirrored = true;

    // ========= å–®å¼µè²¼åœ–ï¼ˆä½¿ç”¨ä½ ä¸Šå‚³çš„åœ–ï¼‰=========
    const dragonImg = new Image();
    // è«‹æ›æˆä½ çš„å¯¦éš›è·¯å¾‘æˆ–æª”å
    dragonImg.src = 'image_2.png';
    let dragonImgReady = false;
    dragonImg.onload = () => { dragonImgReady = true; };

    // æ­£æ–¹å½¢è²¼åœ–å»ºè­°å€¼ï¼šå°ºå¯¸èˆ‡éŒ¨é»
    const sprite = {
      drawWidth: 360,
      drawHeight: 360,
      headAnchorX: 0.32
    };

    // ç›®æ¨™ç‰©ä»¶
    const goodList = ['ç¦', 'æ˜¥', 'è²¡', 'å®‰', 'æ—º', 'å‰', 'ç¥¥', 'è³€', 'é¾', 'å¹´'];
    const badList  = ['âš½', 'ğŸ”', 'ğŸ§', 'ğŸ§Š', 'ğŸ§¼', 'ğŸº', 'ğŸ’¡', 'ğŸ“', 'ğŸ§½', 'ğŸ§¯'];
    const items = [];
    const MAX_ITEMS = 14;

    // ç²’å­
    const particles = [];

    // ========= ç•«å¸ƒå¤§å° =========
    function resize() {
      dpr = Math.min(window.devicePixelRatio || 1, 2);
      const rect = canvas.getBoundingClientRect();
      W = rect.width; H = rect.height;
      canvas.width = Math.round(W * dpr);
      canvas.height = Math.round(H * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize);
    window.addEventListener('orientationchange', () => setTimeout(resize, 150));
    resize();

    // ========= èƒ½åŠ›æª¢æŸ¥ =========
    function supported() {
      const ok = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
      if (!ok) {
        hintEl.textContent = 'æ­¤è£ç½®æˆ–ç€è¦½å™¨ä¸æ”¯æ´ç›¸æ©Ÿã€‚è«‹ä½¿ç”¨æœ€æ–°ç‰ˆ Chrome / Safari ä¸¦ç¢ºä¿ HTTPSã€‚';
        hintEl.className = 'hint bad';
      }
      if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
        hintEl.textContent = 'è«‹ä½¿ç”¨ HTTPS ç¶²ç«™ä»¥é–‹å•Ÿç›¸æ©Ÿæ¬Šé™ã€‚';
        hintEl.className = 'hint bad';
      }
      return ok;
    }

    // ========= ç›¸æ©Ÿ =========
    let currentStream = null;
    async function stopStream() {
      if (currentStream) { currentStream.getTracks().forEach(t => t.stop()); currentStream = null; }
    }
    async function initCamera() {
      const kinds = [
        { width: { ideal: 1280 }, height: { ideal: 720 } },
        { width: { ideal: 960 }, height: { ideal: 540 } },
        { width: { ideal: 640 }, height: { ideal: 480 } }
      ];
      const facing = useEnvironment ? { ideal: 'environment' } : { ideal: 'user' };
      let lastErr = null;
      await stopStream();
      for (const res of kinds) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: false, video: { ...res, facingMode: facing } });
          currentStream = stream;
          video.srcObject = stream;
          await video.play();
          video.playsInline = true;
          applyMirror();
          return true;
        } catch (err) { lastErr = err; }
      }
      console.error('Camera init failed:', lastErr);
      hintEl.textContent = 'ç›¸æ©Ÿç„¡æ³•å•Ÿå‹•ï¼Œè«‹æª¢æŸ¥æ¬Šé™/ç€è¦½å™¨è¨­å®šæˆ–æ”¹ç”¨å…¶ä»–è£ç½®ã€‚';
      hintEl.className = 'hint bad';
      return false;
    }
    function applyMirror() { video.style.transform = mirrored ? 'scaleX(-1)' : 'none'; }

    // ========= é¡è‰²è¿½è¹¤ =========
    const workCanvas = document.createElement('canvas');
    const wctx = workCanvas.getContext('2d', { willReadFrequently: true });

    function rgb2hsv(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
      let h=0; if(d!==0){ if(max===r) h=((g-b)/d)%6; else if(max===g) h=(b-r)/d+2; else h=(r-g)/d+4; h*=60; }
      if(h<0) h+=360; const s=max===0?0:d/max; const v=max; return [h,s*100,v*100];
    }
    function inHueRange(h, hMin, hMax){ return hMin<=hMax ? (h>=hMin && h<=hMax) : (h>=hMin || h<=hMax); }

    function trackRedCentroid() {
      if (video.videoWidth===0 || video.videoHeight===0) return null;
      const scale = 0.22;
      const w = Math.max(2, Math.round(video.videoWidth * scale));
      const h = Math.max(2, Math.round(video.videoHeight * scale));
      workCanvas.width = w; workCanvas.height = h;
      wctx.drawImage(video, 0, 0, w, h);
      const { data } = wctx.getImageData(0, 0, w, h);

      const hMin = parseInt(hMinEl.value, 10);
      const hMax = parseInt(hMaxEl.value, 10);
      const sMin = parseInt(sMinEl.value, 10);
      const vMin = parseInt(vMinEl.value, 10);
      const sens = parseInt(sensEl.value, 10);

      let sumX=0,sumY=0,count=0;
      const step=2;
      for (let y=0; y<h; y+=step){
        for (let x=0; x<w; x+=step){
          const i=(y*w+x)*4;
          const r=data[i], g=data[i+1], b=data[i+2];
          const [hh,ss,vv]=rgb2hsv(r,g,b);
          if (inHueRange(hh,hMin,hMax) && ss>=sMin && vv>=vMin){ sumX+=x; sumY+=y; count++; }
        }
      }
      if (count < sens) return null;
      const cx = (sumX / count) / w * W;
      const cy = (sumY / count) / h * H;
      return { x: cx, y: cy, count };
    }

    // ========= ç‰©ä»¶ =========
    function spawnItem() {
      const isGood = Math.random() < 0.6;
      const text = isGood ? goodList[Math.floor(Math.random()*goodList.length)] : badList[Math.floor(Math.random()*badList.length)];
      const size = 28 + Math.random()*18;
      const margin = 28 + size;
      const x = margin + Math.random()*(W - margin*2);
      const y = 80 + Math.random()*(H - 160);
      const speed = parseInt(speedEl.value, 10);
      const vx = (Math.random()-0.5)*speed;
      const vy = (Math.random()-0.5)*speed;
      const ttl = 12 + Math.random()*10;
      items.push({ x,y,vx,vy,text,size,isGood,ttl });
    }
    function ensureItems() {
      const target = parseInt(densEl.value, 10) * 3;
      while (items.length < Math.min(MAX_ITEMS, target)) spawnItem();
    }
    function updateItems(dt) {
      for (let i=items.length-1; i>=0; i--){
        const it=items[i];
        it.x += it.vx; it.y += it.vy; it.ttl -= dt;
        if (it.x<20 || it.x>W-20) it.vx*=-1;
        if (it.y<60 || it.y>H-60) it.vy*=-1;
        if (it.ttl<=0) items.splice(i,1);
      }
      ensureItems();
    }
    function drawItems(ctx) {
      for (const it of items){
        ctx.save();
        ctx.font = `700 ${it.size}px system-ui, "Noto Color Emoji", "Apple Color Emoji"`;
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.shadowColor = it.isGood ? 'rgba(255,215,0,0.9)' : 'rgba(255,90,0,0.7)';
        ctx.shadowBlur = 12;
        ctx.fillStyle = it.isGood ? '#ffd166' : '#ff6b6b';
        ctx.fillText(it.text, it.x, it.y);
        ctx.restore();
      }
    }

    // ========= ç²’å­ï¼ˆé¦™æŸç«é»ï¼‰=========
    function spawnIncenseParticles(pos, dir, count=6) {
      for (let i=0; i<count; i++){
        const angle = Math.atan2(dir.y, dir.x) + (Math.random()*0.8 - 0.4);
        const speed = 40 + Math.random()*120;
        const vx = Math.cos(angle)*speed;
        const vy = Math.sin(angle)*speed - Math.random()*20;
        particles.push({
          x: pos.x + (Math.random()*6-3),
          y: pos.y + (Math.random()*6-3),
          vx, vy,
          life: 0.45 + Math.random()*0.35,
          age: 0,
          size: 2 + Math.random()*2.5,
          hue: 20 + Math.random()*20
        });
      }
    }
    function updateParticles(dt) {
      for (let i=particles.length-1; i>=0; i--){
        const p = particles[i];
        p.age += dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 20 * dt;
        if (p.age >= p.life) particles.splice(i,1);
      }
    }
    function drawParticles(ctx) {
      for (const p of particles){
        const t = p.age / p.life;
        const alpha = 1 - t;
        const size = p.size * (0.8 + 0.4*(1-t));
        const col = `hsla(${p.hue}, 90%, ${60 - t*30}%, ${alpha})`;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = col;
        ctx.beginPath(); ctx.arc(p.x, p.y, size, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }

    // ========= å–®å¼µè²¼åœ–ç¹ªè£½ï¼ˆæœ‰æ—‹è½‰ã€ç„¡æ“ºå‹•ï¼‰=========
    function drawDragon(ctx, head, dir) {
      if (!dragonImgReady) return;

      const angle = Math.atan2(dir.y, dir.x);
      const imgW = sprite.drawWidth;
      const imgH = sprite.drawHeight;

      ctx.save();
      ctx.translate(head.x, head.y);
      ctx.rotate(angle);

      // æ°´å¹³å°é½Šåˆ°é¾é ­
      const headOffsetX = -imgW * sprite.headAnchorX;
      // å‚ç›´å¾®èª¿ï¼šæ­¤åœ–é¾é ­ç•¥é«˜æ–¼ä¸­å¿ƒï¼Œå¾€ä¸Šç§» 12% é«˜åº¦
      const headOffsetY = -imgH * 0.12;

      ctx.translate(headOffsetX, headOffsetY);
      // æ³¨æ„ï¼šé€™å¼µåœ–å«èƒŒæ™¯ï¼Œæœƒæ•´å¼µä¸€èµ·ç§»å‹•ï¼›è‹¥ç”¨å»èƒŒ PNG è¦–è¦ºæ›´ä½³
      ctx.drawImage(dragonImg, 0, -imgH * 0.5, imgW, imgH);

      // ç²’å­æ–¹å‘èˆ‡è²¼åœ–æœå‘ä¸€è‡´
      spawnIncenseParticles({ x: 0, y: 0 }, { x: 1, y: 0 }, 8);

      ctx.restore();
    }

    // ========= ç¢°æ’èˆ‡å¾—åˆ† =========
    function circleHit(ax, ay, bx, by, r) {
      const dx = ax - bx, dy = ay - by;
      return (dx*dx + dy*dy) <= r*r;
    }
    function handleCollisions(head) {
      for (let i=items.length-1; i>=0; i--){
        const it=items[i];
        const radius = Math.max(28, sprite.drawHeight * 0.4);
        if (circleHit(head.x, head.y, it.x, it.y, radius)){
          if (it.isGood){
            combo++;
            const bonus = 10 + Math.min(60, combo*2);
            score += bonus;
            flash('+ ' + bonus, it.x, it.y, true);
          } else {
            combo = 0;
            score = Math.max(0, score - 15);
            flash('âˆ’ 15', it.x, it.y, false);
          }
          items.splice(i,1);
          scoreEl.textContent = score;
          comboEl.textContent = combo;
        }
      }
    }

    const floatTexts = [];
    function flash(text, x, y, ok) { floatTexts.push({ text, x, y, ok, t: 0 }); }
    function drawFloatTexts(dt) {
      for (let i=floatTexts.length-1; i>=0; i--){
        const f=floatTexts[i]; f.t += dt;
        const alpha = Math.max(0, 1 - f.t/1.2);
        const dy = -f.t*40;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font = '800 22px system-ui';
        ctx.textAlign = 'center'; ctx.textBaseline='middle';
        ctx.fillStyle = f.ok ? '#22c55e' : '#f97316';
        ctx.fillText(f.text, f.x, f.y + dy);
        ctx.restore();
        if (alpha <= 0.01) floatTexts.splice(i,1);
      }
    }

    // ========= ä¸»å¾ªç’° =========
    let lastTime = performance.now();
    function tick(now) {
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;

      ctx.clearRect(0, 0, W, H);

      const c = trackRedCentroid();
      if (c) {
        const prevX = centroid.x || c.x, prevY = centroid.y || c.y;
        centroid.x = centroid.x + (c.x - centroid.x) * smoothing || c.x;
        centroid.y = centroid.y + (c.y - centroid.y) * smoothing || c.y;
        const dx = centroid.x - prevX, dy = centroid.y - prevY;
        const len = Math.hypot(dx, dy) || 1;
        direction.x = dx / len; direction.y = dy / len;
        hintEl.textContent = 'å·²åµæ¸¬åˆ°ç´…è‰²ç›®æ¨™ï¼Œç›¡æƒ…èˆå‹•ï¼'; hintEl.className = 'hint ok';
      } else {
        hintEl.textContent = 'æœªåµæ¸¬åˆ°ç´…è‰²ç‰©ä»¶ï¼Œè«‹èª¿æ•´å…‰ç·š/è‰²åŸŸæˆ–é è¿‘é¡é ­ã€‚'; hintEl.className = 'hint bad';
      }

      updateItems(dt);
      drawItems(ctx);

      const head = { x: centroid.x || W/2, y: centroid.y || H/2 };
      drawDragon(ctx, head, direction);

      updateParticles(dt);
      drawParticles(ctx);

      handleCollisions(head);
      drawFloatTexts(dt);

      if (running && !gameOver) requestAnimationFrame(tick);
    }

    // ========= æ§åˆ¶ =========
    function startGameLoop() {
      if (running) return;
      running = true; gameOver = false;
      lastTime = performance.now();
      ensureItems();
      clearInterval(timerId);
      timeLeft = 60;
      timeEl.textContent = timeLeft;
      timerId = setInterval(() => {
        timeLeft--; timeEl.textContent = timeLeft;
        if (timeLeft <= 0) {
          clearInterval(timerId);
          running = false; gameOver = true;
          hintEl.textContent = `æ™‚é–“åˆ°ï¼ç¸½åˆ†ï¼š${score}`;
          hintEl.className = 'hint';
        }
      }, 1000);
      requestAnimationFrame(tick);
    }

    async function startAll() {
      if (!supported()) return;
      startBtn.disabled = true;
      try {
        const ok = await initCamera();
        if (ok) startGameLoop(); else startBtn.disabled = false;
      } catch (err) {
        console.error(err);
        hintEl.textContent = 'ç›¸æ©Ÿç„¡æ³•å•Ÿå‹•ï¼Œè«‹ç¢ºèªæ¬Šé™èˆ‡ HTTPSã€‚';
        hintEl.className = 'hint bad';
        startBtn.disabled = false;
      }
    }

    startBtn.addEventListener('click', startAll);

    resetBtn.addEventListener('click', async () => {
      score = 0; combo = 0; scoreEl.textContent = score; comboEl.textContent = combo;
      items.length = 0; ensureItems();
      centroid = { x: W/2, y: H/2 };
      direction = { x: 1, y: 0 };
      hintEl.textContent = 'é‡ç½®å®Œæˆï¼ŒæŒ‰ã€Œé–‹å§‹ã€é‡æ–°å•Ÿå‹•ç›¸æ©Ÿã€‚';
      running = false; gameOver = false;
      clearInterval(timerId);
      startBtn.disabled = false;
      await stopStream();
    });

    toggleFacingBtn.addEventListener('click', async () => { useEnvironment = !useEnvironment; await initCamera(); });
    toggleMirrorBtn.addEventListener('click', () => { mirrored = !mirrored; applyMirror(); toggleMirrorBtn.textContent = `é¡åƒï¼š${mirrored ? 'é–‹' : 'é—œ'}`; });
    fullscreenBtn.addEventListener('click', () => {
      const el = document.documentElement;
      if (!document.fullscreenElement) { (el.requestFullscreen && el.requestFullscreen()) || (el.webkitRequestFullscreen && el.webkitRequestFullscreen()); }
      else { (document.exitFullscreen && document.exitFullscreen()) || (document.webkitExitFullscreen && document.webkitExitFullscreen()); }
    });

    // åˆå§‹
    centroid = { x: W/2, y: H/2 };
    direction = { x: 1, y: 0 };

    bgImg.src = 'image_1.png';
  </script>
</body>
</html>
