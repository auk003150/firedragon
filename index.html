<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Hiro Marker AR Demo + ç¢°æ’èˆ‡åˆ†æ•¸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <!-- AR.js for A-Frame -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; }
    body { font-family: system-ui, -apple-system, "Helvetica Neue", Arial, sans-serif; }
    .overlay {
      position: fixed;
      top: 0; left: 0; right: 0;
      display: flex; justify-content: space-between; align-items: center;
      padding: 12px 16px;
      background: linear-gradient(180deg, rgba(0,0,0,0.65), rgba(0,0,0,0));
      color: #fff; z-index: 10; pointer-events: none;
      font-size: 14px;
    }
    .hint {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      padding: 10px 14px;
      background: linear-gradient(0deg, rgba(0,0,0,0.7), rgba(0,0,0,0));
      color: #fff; z-index: 10; text-align: center;
      font-size: 13px; pointer-events: none;
    }
    .badge {
      background: rgba(255,255,255,0.12);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      pointer-events: auto;
    }
    .link {
      color: #9ad6ff; text-decoration: underline; pointer-events: auto;
    }
    .score {
      pointer-events: none;
      font-weight: 600;
    }
    @media (max-width: 640px) {
      .overlay { font-size: 13px; padding: 10px 12px; }
      .hint { font-size: 12px; padding: 8px 12px; }
    }
  </style>
</head>
<body>
  <div class="overlay">
    <div class="badge">Hiro Marker AR</div>
    <div class="score" id="score">åˆ†æ•¸ï¼š0</div>
  </div>
  <div class="hint">
    å°‡ Hiro æ¨™è¨˜ç½®æ–¼é¡é ­å‰æ–¹ï¼Œ3D ç‰©ä»¶æœƒå‡ºç¾åœ¨æ¨™è¨˜ä¸Šã€‚<br/>
    æ²’æœ‰æ¨™è¨˜ï¼Ÿå¯åˆ—å°ï¼š<a class="link" href="https://raw.githubusercontent.com/AR-js-org/AR.js/master/aframe/examples/marker-training/examples/pattern-files/pattern-hiro.png" target="_blank" rel="noopener">ä¸‹è¼‰ Hiro åœ–</a><br/>
    æç¤ºï¼šç§»å‹•æ¨™è¨˜å»ç¢°è§¸è¢å¹•ä¸­çš„å­—å…ƒä¾†åŠ æ¸›åˆ†ï¼
  </div>

  <a-scene
    vr-mode-ui="enabled: false"
    embedded
    renderer="logarithmicDepthBuffer: true; antialias: true;"
    arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono; maxDetectionRate: 30;"
  >
    <!-- å…‰æº -->
    <a-entity light="type: ambient; color: #cccccc"></a-entity>
    <a-entity light="type: directional; color: #ffffff; intensity: 0.8" position="1 1 0.5"></a-entity>

    <!-- Hiro æ¨™è¨˜ï¼ˆç©å®¶ï¼‰ -->
    <a-marker preset="hiro" id="marker">
      <!-- ç©å®¶ç¢°æ’é«”ï¼šæ—‹è½‰ç«‹æ–¹é«”ï¼ˆåŒä½ åŸæœ‰çš„ï¼‰ -->
      <a-box id="player"
             position="0 0.5 0"
             depth="1" height="1" width="1"
             color="#4FC3F7"
             animation="property: rotation; to: 0 360 0; loop: true; dur: 4000; easing: linear">
      </a-box>
      <!-- ä¸€å€‹å°åœ“æŸ±ç•¶åº•åº§ -->
      <a-cylinder position="0 0 0" radius="0.35" height="0.1" color="#FFC107"></a-cylinder>
    </a-marker>

    <!-- ç›¸æ©Ÿ -->
    <a-entity camera id="camera"></a-entity>

    <!-- å­—å…ƒå®¹å™¨ï¼ˆåœ¨ä¸–ç•Œä¸­ä»¥ç›¸æ©Ÿåº§æ¨™ / è¦–åŸŸå¹³é¢æ§åˆ¶ï¼‰ -->
    <a-entity id="targets-root"></a-entity>

    <script>
      // åƒæ•¸è¨­å®š
      const FIRST_SET = ['ç¦', 'æ˜¥', 'è²¡', 'å®‰', 'æ—º', 'å‰', 'ç¥¥', 'è³€', 'é¾', 'å¹´'];
      const SECOND_SET = ['âš½', 'ğŸ”', 'ğŸ§', 'ğŸ§Š', 'ğŸ§¼', 'ğŸº', 'ğŸ’¡', 'ğŸ“', 'ğŸ§½', 'ğŸ§¯'];

      const COUNT_PER_SET = 10;       // æ¯çµ„ 10 å€‹
      const PLANE_Z = -2;             // å­—å…ƒæ‰€åœ¨çš„ç›¸æ©Ÿå‰æ–¹å›ºå®šæ·±åº¦ï¼ˆå…¬å°ºï¼‰
      const SPEED_MIN = 60;           // æ¯ç§’æœ€å°é€Ÿåº¦ï¼ˆè¢å¹•åƒç´ ï¼‰
      const SPEED_MAX = 160;          // æ¯ç§’æœ€å¤§é€Ÿåº¦ï¼ˆè¢å¹•åƒç´ ï¼‰
      const TEXT_WORLD_SCALE = 0.5;   // å­—å…ƒåœ¨ä¸–ç•Œçš„ç¸®æ”¾ï¼ˆå›ºå®šå¤§å°ï¼‰
      const COLLIDE_RADIUS = 0.75;    // ç¢°æ’åŠå¾‘ï¼ˆå…¬å°ºï¼Œä¾ä½ æ–¹å¡Š 1m å°ºå¯¸å¤§è‡´è¨­å®šï¼‰
      const SCORE_HIT_FIRST = 15;     // ç¬¬ä¸€çµ„åŠ åˆ†
      const SCORE_HIT_SECOND = -5;    // ç¬¬äºŒçµ„æ‰£åˆ†
      const HIT_COOLDOWN_MS = 600;    // åŒä¸€ç›®æ¨™é€£çºŒç¢°æ’å†·å»

      const scene = document.querySelector('a-scene');
      const cameraEl = document.getElementById('camera');
      const markerEl = document.getElementById('marker');
      const playerEl = document.getElementById('player');
      const targetsRoot = document.getElementById('targets-root');
      const scoreEl = document.getElementById('score');

      let score = 0;

      // å·¥å…·ï¼šè¢å¹•åº§æ¨™ <-> ä¸–ç•Œåº§æ¨™ï¼ˆåœ¨ç›¸æ©Ÿå‰æ–¹å›ºå®šæ·±åº¦ï¼‰
      function screenToWorldAtZ(x, y, zMeters) {
        // å–å¾—ç›¸æ©Ÿä¸‰è¦ç´ 
        const cam = cameraEl.getObject3D('camera');
        const obj = cameraEl.object3D;
        if (!cam) return null;
        // NDC è½‰æ›
        const ndcX = (x / window.innerWidth) * 2 - 1;
        const ndcY = -(y / window.innerHeight) * 2 + 1;
        const ndc = new THREE.Vector3(ndcX, ndcY, 0.5);

        // å°„ç·šå¾ç›¸æ©Ÿå‡ºç™¼ï¼Œå–å¾—åœ¨è·é›¢ zMeters çš„é»
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(ndc, cam);

        const origin = raycaster.ray.origin.clone();
        const dir = raycaster.ray.direction.clone().normalize();

        // æ‰¾åˆ°èˆ‡ç›¸æ©Ÿå‰æ–¹è·é›¢ç‚º |zMeters| çš„ä½ç½®ï¼ˆæ²¿è‘—è¦–ç·šæ–¹å‘ï¼‰
        const point = origin.add(dir.multiplyScalar(Math.abs(zMeters)));
        return point;
      }

      function worldToScreen(worldVec3) {
        const cam = cameraEl.getObject3D('camera');
        if (!cam) return null;
        const vector = worldVec3.clone();
        vector.project(cam);
        const sx = (vector.x + 1) / 2 * window.innerWidth;
        const sy = (1 - vector.y) / 2 * window.innerHeight;
        return { x: sx, y: sy };
      }

      // å»ºç«‹ä¸€å€‹ç›®æ¨™å­—å…ƒ
      function createTarget(char, type) {
        const el = document.createElement('a-entity');
        // ä½¿ç”¨ A-Frame çš„ text component æ¸²æŸ“å­—/emoji
        el.setAttribute('text', {
          value: char,
          align: 'center',
          width: 2,            // åŸºåº•å¯¬åº¦ï¼šæ­é… scale å¾—åˆ°ç©©å®šå¤§å°
          color: type === 'first' ? '#00E676' : '#FF5252'
        });
        el.setAttribute('scale', `${TEXT_WORLD_SCALE} ${TEXT_WORLD_SCALE} ${TEXT_WORLD_SCALE}`);
        el.setAttribute('position', `0 0 ${PLANE_Z}`); // åˆå€¼ï¼Œç¨å¾Œæœƒé¦¬ä¸Šæ›´æ–°

        // è‡ªè¨‚ç‹€æ…‹
        el.__state = {
          type,
          char,
          // åˆå§‹éš¨æ©Ÿè¢å¹•ä½ç½®ï¼ˆä¿ç•™é‚Šç•Œï¼‰
          sx: Math.random() * (window.innerWidth - 60) + 30,
          sy: Math.random() * (window.innerHeight - 60) + 30,
          // éš¨æ©Ÿæ–¹å‘èˆ‡é€Ÿåº¦ï¼ˆä»¥è¢å¹•åƒç´ /ç§’ï¼‰
          vx: (Math.random() * 2 - 1) * (SPEED_MIN + Math.random() * (SPEED_MAX - SPEED_MIN)),
          vy: (Math.random() * 2 - 1) * (SPEED_MIN + Math.random() * (SPEED_MAX - SPEED_MIN)),
          lastHitAt: 0
        };

        targetsRoot.appendChild(el);
        return el;
      }

      // å»ºç«‹å¤šå€‹ç›®æ¨™
      const targets = [];
      function spawnAllTargets() {
        // ç¬¬ä¸€çµ„
        for (let i = 0; i < COUNT_PER_SET; i++) {
          const c = FIRST_SET[i % FIRST_SET.length];
          targets.push(createTarget(c, 'first'));
        }
        // ç¬¬äºŒçµ„
        for (let i = 0; i < COUNT_PER_SET; i++) {
          const c = SECOND_SET[i % SECOND_SET.length];
          targets.push(createTarget(c, 'second'));
        }
      }

      // æ›´æ–°åˆ†æ•¸é¡¯ç¤º
      function setScore(val) {
        score = val;
        scoreEl.textContent = `åˆ†æ•¸ï¼š${score}`;
      }

      // ç¢°æ’åé¥‹å‹•ç•«ï¼ˆç°¡å–®ç¸®æ”¾é–ƒçˆï¼‰
      function hitFeedback(el) {
        el.setAttribute('animation__hit1', {
          property: 'scale',
          to: `${TEXT_WORLD_SCALE * 1.4} ${TEXT_WORLD_SCALE * 1.4} ${TEXT_WORLD_SCALE * 1.4}`,
          dur: 120,
          easing: 'easeOutQuad',
          dir: 'alternate',
          loop: 1
        });
      }

      // ä¸»æ›´æ–°è¿´åœˆ
      let lastTime = performance.now();

      function tick() {
        const now = performance.now();
        const dt = (now - lastTime) / 1000; // seconds
        lastTime = now;

        // æ›´æ–°æ¯å€‹ç›®æ¨™åœ¨è¢å¹•çš„ 2D ä½ç½®ï¼ˆå½ˆè·³ï¼‰
        const margin = 24;
        const minX = margin, maxX = window.innerWidth - margin;
        const minY = margin, maxY = window.innerHeight - margin;

        for (const el of targets) {
          const st = el.__state;
          if (!st) continue;
          st.sx += st.vx * dt;
          st.sy += st.vy * dt;

          // é‚Šç•Œåå½ˆ
          if (st.sx < minX) { st.sx = minX; st.vx = Math.abs(st.vx); }
          if (st.sx > maxX) { st.sx = maxX; st.vx = -Math.abs(st.vx); }
          if (st.sy < minY) { st.sy = minY; st.vy = Math.abs(st.vy); }
          if (st.sy > maxY) { st.sy = maxY; st.vy = -Math.abs(st.vy); }

          // è½‰æ›åˆ°ä¸–ç•Œåº§æ¨™ï¼ˆç›¸æ©Ÿå‰æ–¹å›ºå®šæ·±åº¦ï¼‰
          const worldPos = screenToWorldAtZ(st.sx, st.sy, Math.abs(PLANE_Z));
          if (worldPos) {
            el.object3D.position.copy(worldPos);
          }
        }

        // å–å¾—ç©å®¶ï¼ˆæ¨™è¨˜ä¸Šçš„æ–¹å¡Šï¼‰ä¸–ç•Œåº§æ¨™
        const playerObj = playerEl.object3D;
        const playerWorldPos = new THREE.Vector3();
        playerObj.getWorldPosition(playerWorldPos);

        // èˆ‡æ¯å€‹ç›®æ¨™åšè·é›¢ç¢°æ’
        const nowMs = now;
        for (const el of targets) {
          const st = el.__state;
          if (!st) continue;

          const targetWorldPos = new THREE.Vector3();
          el.object3D.getWorldPosition(targetWorldPos);

          const dist = playerWorldPos.distanceTo(targetWorldPos);
          if (dist <= COLLIDE_RADIUS) {
            if (nowMs - st.lastHitAt > HIT_COOLDOWN_MS) {
              st.lastHitAt = nowMs;
              // è¨ˆåˆ†
              setScore(score + (st.type === 'first' ? SCORE_HIT_FIRST : SCORE_HIT_SECOND));
              hitFeedback(el);
            }
          }
        }

        requestAnimationFrame(tick);
      }

      // åˆå§‹åŒ–
      function start() {
        spawnAllTargets();
        lastTime = performance.now();
        requestAnimationFrame(tick);
      }

      if (scene.hasLoaded) start();
      else scene.addEventListener('loaded', start);

      // è¦–çª—å°ºå¯¸è®Šæ›´æ™‚ä¸éœ€é‡å»ºï¼Œåªèª¿æ•´åå½ˆé‚è¼¯çš„é‚Šç•Œä¾è³´ window.innerWidth/Height å³å¯
      window.addEventListener('resize', () => {
        // ç„¡éœ€ç‰¹åˆ¥è™•ç†ï¼›tick ä¸­ä½¿ç”¨å³æ™‚çš„ window.innerWidth/Height
      });
    </script>
  </a-scene>
</body>
</html>
