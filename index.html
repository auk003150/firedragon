<!DOCTYPE html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>å¤§å‘èˆç«é¾ AR å°éŠæˆ²ï¼ˆåŸå‹ï¼‰</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; background: #000; color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans HK", "Noto Sans CJK", "PingFang HK", "Heiti TC", Arial, sans-serif;
      overflow: hidden;
    }
    .wrap {
      position: relative;
      width: 100%;
      height: 100%;
      background: #000;
    }
    /* å¾Œç½®é¡é ­å½±åƒ */
    video#cam {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      object-fit: cover; transform: scaleX(-1); /* é¡åƒï¼Œè¼ƒç¬¦åˆè‡ªæ‹æ„Ÿï¼›è‹¥è¦çœŸå¯¦æ–¹å‘å¯ç§»é™¤ */
      filter: none;
    }
    /* 20% é€æ˜åº¦çš„å¤§å‘èˆç«é¾èƒŒæ™¯åœ–ï¼ˆå¯æ›¿æ› srcï¼‰ */
    img#bg {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      object-fit: cover; pointer-events: none;
      opacity: 0.2; mix-blend-mode: lighten;
    }
    /* éŠæˆ²Canvaså±¤ï¼šç«é¾ã€ç›®æ¨™ã€ç¢°æ’ã€UI */
    canvas#game {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      touch-action: none; pointer-events: none;
    }
    /* æ§åˆ¶åˆ— */
    .ui {
      position: absolute; left: 0; right: 0; top: 0;
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 12px; gap: 8px;
      background: linear-gradient(180deg, rgba(0,0,0,0.5), rgba(0,0,0,0));
      user-select: none;
    }
    .btn {
      background: #e11d48; border: none; color: #fff; border-radius: 10px;
      padding: 10px 14px; font-weight: 700; letter-spacing: 0.5px;
      box-shadow: 0 4px 12px rgba(225,29,72,0.35);
    }
    .btn:active { transform: translateY(1px); }
    .hud {
      display: flex; gap: 10px; align-items: center; font-weight: 700;
      text-shadow: 0 2px 6px rgba(0,0,0,0.6);
    }
    .chip {
      background: rgba(0,0,0,0.45); border: 1px solid rgba(255,255,255,0.2);
      border-radius: 999px; padding: 6px 10px; font-size: 14px;
    }
    .bar {
      position: absolute; left: 12px; right: 12px; bottom: 12px;
      display: flex; gap: 8px; flex-wrap: wrap; align-items: center;
      background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px; padding: 10px;
    }
    .range-group {
      display: flex; align-items: center; gap: 8px; color: #ddd; font-size: 12px;
    }
    input[type="range"] { width: 120px; }
    .hint {
      position: absolute; left: 0; right: 0; top: 50%;
      transform: translateY(-50%);
      text-align: center; padding: 0 16px; color: #ffd166; font-weight: 700;
      text-shadow: 0 2px 10px rgba(0,0,0,0.7);
    }
    .ok { color: #22c55e; }
    .bad { color: #f97316; }
  </style>
</head>
<body>
  <div class="wrap">
    <video id="cam" playsinline muted autoplay></video>
    <!-- å°‡æ­¤ img çš„ src æ›æˆä½ æä¾›çš„èƒŒæ™¯åœ–ï¼ˆä¾‹å¦‚ä½ ä¸Šè¼‰çš„å·¡éŠåœ–ç‰‡ï¼‰ã€‚-->
    <img id="bg" alt="å¤§å‘èˆç«é¾èƒŒæ™¯" src="" />
    <canvas id="game"></canvas>

    <div class="ui">
      <button id="startBtn" class="btn">é–‹å§‹</button>
      <div class="hud">
        <div class="chip">åˆ†æ•¸ï¼š<span id="score">0</span></div>
        <div class="chip">Comboï¼š<span id="combo">0</span></div>
        <div class="chip">æ™‚é–“ï¼š<span id="time">60</span>s</div>
      </div>
      <button id="resetBtn" class="btn" style="background:#334155">é‡ç½®</button>
    </div>

    <div class="bar">
      <div class="range-group">
        Hmin <input id="hMin" type="range" min="0" max="360" value="330">
        Hmax <input id="hMax" type="range" min="0" max="360" value="20">
      </div>
      <div class="range-group">
        Smin <input id="sMin" type="range" min="0" max="100" value="50">
        Vmin <input id="vMin" type="range" min="0" max="100" value="40">
      </div>
      <div class="range-group">
        éˆæ•åº¦ <input id="sens" type="range" min="0" max="100" value="60">
      </div>
      <div class="range-group">
        ç›®æ¨™å¯†åº¦ <input id="density" type="range" min="1" max="10" value="4">
      </div>
      <div class="range-group">
        é€Ÿåº¦ <input id="speed" type="range" min="1" max="10" value="5">
      </div>
    </div>

    <div id="hint" class="hint">æŒ‰ã€Œé–‹å§‹ã€å…è¨±ç›¸æ©Ÿæ¬Šé™ã€‚è«‹ä»¥ç´…è‰²é¾å…¬ä»”åœ¨é¡é ­å‰æ®å‹•ã€‚</div>
  </div>

  <script>
    // ========= åŸºæœ¬è¨­å®š =========
    const video = document.getElementById('cam');
    const bgImg = document.getElementById('bg');
    // å¦‚æœ‰å¯¦éš›èƒŒæ™¯åœ–ï¼Œè¨­ç½® srcï¼šbgImg.src = 'your-dahing-photo.jpg';
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: true });

    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const scoreEl = document.getElementById('score');
    const comboEl = document.getElementById('combo');
    const timeEl = document.getElementById('time');
    const hintEl = document.getElementById('hint');

    const hMinEl = document.getElementById('hMin');
    const hMaxEl = document.getElementById('hMax');
    const sMinEl = document.getElementById('sMin');
    const vMinEl = document.getElementById('vMin');
    const sensEl = document.getElementById('sens');
    const densEl = document.getElementById('density');
    const speedEl = document.getElementById('speed');

    let running = false;
    let gameOver = false;
    let W = 0, H = 0;

    let score = 0, combo = 0, timeLeft = 60;
    let timerId = null;

    // è¿½è¹¤ç‹€æ…‹
    let centroid = { x: 0, y: 0 };
    let lastCentroid = { x: 0, y: 0 };
    let direction = { x: 0, y: 0 }; // å–®ä½æ–¹å‘
    let dragonLen = 80; // ç«é¾é¡¯ç¤ºçš„ä¸»é«”é•·åº¦ï¼ˆé ­å°¾è·ï¼‰
    let smoothing = 0.25; // ä½ç½®å¹³æ»‘

    // ç›®æ¨™ç‰©ä»¶ï¼ˆè³€å¹´è©ã€éè³€å¹´ï¼‰
    const goodList = ['ç¦', 'æ˜¥', 'è²¡', 'å®‰', 'æ—º', 'å‰', 'ç¥¥', 'è³€', 'é¾', 'å¹´'];
    const badList  = ['âš½', 'ğŸ”', 'ğŸ§', 'ğŸ§Š', 'ğŸ§¼', 'ğŸº', 'ğŸ’¡', 'ğŸ“', 'ğŸ§½', 'ğŸ§¯'];

    const items = [];
    const MAX_ITEMS = 12;

    // èª¿æ•´ç•«å¸ƒå¤§å°
    function resize() {
      const dpr = Math.min(window.devicePixelRatio || 1.5, 2);
      W = canvas.clientWidth;
      H = canvas.clientHeight;
      canvas.width = Math.round(W * dpr);
      canvas.height = Math.round(H * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    // ========= é–‹ç›¸æ©Ÿï¼ˆå¾Œç½®ï¼‰=========
    async function initCamera() {
      const constraints = {
        audio: false,
        video: {
          facingMode: { ideal: 'environment' },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        }
      };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      await video.play();
    }

    // ========= é¡è‰²è¿½è¹¤ï¼ˆç°¡åŒ– HSVï¼‰=========
    const workCanvas = document.createElement('canvas');
    const wctx = workCanvas.getContext('2d', { willReadFrequently: true });

    function rgb2hsv(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      const d = max - min;
      let h = 0;
      if (d !== 0) {
        if (max === r) h = ((g - b) / d) % 6;
        else if (max === g) h = (b - r) / d + 2;
        else h = (r - g) / d + 4;
        h *= 60;
      }
      if (h < 0) h += 360;
      const s = max === 0 ? 0 : d / max;
      const v = max;
      return [h, s * 100, v * 100];
    }

    function inHueRange(h, hMin, hMax) {
      // æ”¯æ´è·¨ 0/360 çš„ç’°ç‹€å€é–“
      if (hMin <= hMax) return h >= hMin && h <= hMax;
      return h >= hMin || h <= hMax;
    }

    function trackRedCentroid() {
      const scale = 0.3; // ä½è§£æåŠ é€Ÿ
      const w = Math.max(2, Math.round(video.videoWidth * scale));
      const h = Math.max(2, Math.round(video.videoHeight * scale));
      workCanvas.width = w; workCanvas.height = h;
      wctx.drawImage(video, 0, 0, w, h);
      const { data } = wctx.getImageData(0, 0, w, h);

      const hMin = parseInt(hMinEl.value, 10);
      const hMax = parseInt(hMaxEl.value, 10);
      const sMin = parseInt(sMinEl.value, 10);
      const vMin = parseInt(vMinEl.value, 10);
      const sens = parseInt(sensEl.value, 10);

      let sumX = 0, sumY = 0, count = 0;

      for (let y = 0; y < h; y += 1) {
        for (let x = 0; x < w; x += 1) {
          const i = (y * w + x) * 4;
          const r = data[i], g = data[i+1], b = data[i+2];
          const [hh, ss, vv] = rgb2hsv(r, g, b);
          if (inHueRange(hh, hMin, hMax) && ss >= sMin && vv >= vMin) {
            sumX += x; sumY += y; count++;
          }
        }
      }

      if (count < sens) {
        return null; // ä¸è¶³åƒç´ ï¼Œè¦–ç‚ºæœªåµæ¸¬
      }

      const cx = (sumX / count) / w * W;
      const cy = (sumY / count) / h * H;

      return { x: cx, y: cy, count };
    }

    // ========= éŠæˆ²ç‰©ä»¶ =========
    function spawnItem() {
      const isGood = Math.random() < 0.6;
      const text = isGood ? goodList[Math.floor(Math.random() * goodList.length)]
                          : badList[Math.floor(Math.random() * badList.length)];
      const size = 28 + Math.random() * 18;
      const x = 30 + Math.random() * (W - 60);
      const y = 80 + Math.random() * (H - 160);
      const vx = (Math.random() - 0.5) * parseInt(speedEl.value, 10);
      const vy = (Math.random() - 0.5) * parseInt(speedEl.value, 10);
      const ttl = 12 + Math.random() * 10;
      items.push({ x, y, vx, vy, text, size, isGood, ttl });
    }

    function ensureItems() {
      const target = parseInt(densEl.value, 10) * 3;
      while (items.length < Math.min(MAX_ITEMS, target)) spawnItem();
    }

    function updateItems(dt) {
      for (let i = items.length - 1; i >= 0; i--) {
        const it = items[i];
        it.x += it.vx;
        it.y += it.vy;
        it.ttl -= dt;
        // é‚Šç•Œå½ˆè·³
        if (it.x < 20 || it.x > W - 20) it.vx *= -1;
        if (it.y < 60 || it.y > H - 60) it.vy *= -1;
        if (it.ttl <= 0) items.splice(i, 1);
      }
      ensureItems();
    }

    function drawItems(ctx) {
      for (const it of items) {
        ctx.save();
        ctx.font = `700 ${it.size}px system-ui, "Noto Color Emoji", "Apple Color Emoji"`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = it.isGood ? 'rgba(255,215,0,0.9)' : 'rgba(255,90,0,0.7)';
        ctx.shadowBlur = 12;
        ctx.fillStyle = it.isGood ? '#ffd166' : '#ff6b6b';
        ctx.fillText(it.text, it.x, it.y);
        ctx.restore();
      }
    }

    // ========= ç«é¾ç¹ªè£½ =========
    function drawDragon(ctx, head, dir) {
      // é ­éƒ¨
      const nx = dir.x, ny = dir.y;
      const angle = Math.atan2(ny, nx);
      const headLen = 26;
      ctx.save();
      ctx.translate(head.x, head.y);
      ctx.rotate(angle);

      // ç«ç„°å…‰æšˆ
      const grad = ctx.createRadialGradient(0, 0, 8, 0, 0, 60);
      grad.addColorStop(0, 'rgba(255,200,80,0.9)');
      grad.addColorStop(0.6, 'rgba(255,120,0,0.35)');
      grad.addColorStop(1, 'rgba(255,0,0,0.05)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(0, 0, 40, 0, Math.PI * 2);
      ctx.fill();

      // é¾é ­
      ctx.fillStyle = '#ff3b30';
      ctx.strokeStyle = '#ffee99';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-headLen, -12);
      ctx.lineTo(-headLen - 6, 0);
      ctx.lineTo(-headLen, 12);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // çœ¼ç›
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(-10, -6, 3, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(-10,  6, 3, 0, Math.PI*2); ctx.fill();

      // èº«é«”ï¼ˆæ³¢æµªï¼‰
      ctx.strokeStyle = '#ff9f1c';
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      for (let i = 1; i <= 12; i++) {
        const t = i / 12;
        const dx = -t * dragonLen;
        const dy = Math.sin((performance.now()/200) + i) * 6;
        ctx.lineTo(dx, dy);
      }
      ctx.stroke();

      ctx.restore();
    }

    // ========= ç¢°æ’èˆ‡å¾—åˆ† =========
    function circleHit(ax, ay, bx, by, r) {
      const dx = ax - bx, dy = ay - by;
      return (dx*dx + dy*dy) <= r*r;
    }

    function handleCollisions(head) {
      for (let i = items.length - 1; i >= 0; i--) {
        const it = items[i];
        if (circleHit(head.x, head.y, it.x, it.y, 28)) {
          if (it.isGood) {
            combo++;
            const bonus = 10 + Math.min(50, combo * 2);
            score += bonus;
            flash('+ ' + bonus, it.x, it.y, true);
          } else {
            combo = 0;
            score -= 15;
            flash('âˆ’ 15', it.x, it.y, false);
          }
          items.splice(i, 1);
          scoreEl.textContent = score;
          comboEl.textContent = combo;
        }
      }
    }

    const floatTexts = [];
    function flash(text, x, y, ok) {
      floatTexts.push({ text, x, y, ok, t: 0 });
    }
    function drawFloatTexts(dt) {
      for (let i = floatTexts.length - 1; i >= 0; i--) {
        const f = floatTexts[i];
        f.t += dt;
        const alpha = Math.max(0, 1 - f.t / 1.2);
        const dy = -f.t * 40;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.font = '800 22px system-ui';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillStyle = f.ok ? '#22c55e' : '#f97316';
        ctx.fillText(f.text, f.x, f.y + dy);
        ctx.restore();
        if (alpha <= 0.01) floatTexts.splice(i, 1);
      }
    }

    // ========= ä¸»å¾ªç’° =========
    let lastTime = performance.now();

    function tick(now) {
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;

      ctx.clearRect(0, 0, W, H);

      // è¿½è¹¤ç´…è‰²æ¨™çš„
      const c = trackRedCentroid();
      if (c) {
        lastCentroid.x = centroid.x || c.x;
        lastCentroid.y = centroid.y || c.y;
        centroid.x = centroid.x + (c.x - centroid.x) * smoothing || c.x;
        centroid.y = centroid.y + (c.y - centroid.y) * smoothing || c.y;

        // æ–¹å‘ï¼ˆå–®ä½ï¼‰
        const dx = centroid.x - lastCentroid.x;
        const dy = centroid.y - lastCentroid.y;
        const len = Math.hypot(dx, dy) || 1;
        direction.x = dx / len;
        direction.y = dy / len;

        hintEl.textContent = 'å·²åµæ¸¬åˆ°ç´…è‰²ç›®æ¨™ï¼Œç›¡æƒ…èˆå‹•ï¼';
        hintEl.className = 'hint ok';
      } else {
        // ç„¡åµæ¸¬ï¼Œç”¨ä¸Šæ¬¡æ–¹å‘ï¼Œæç¤ºä½¿ç”¨è€…
        hintEl.textContent = 'æœªåµæ¸¬åˆ°ç´…è‰²ç‰©ä»¶ï¼Œè«‹èª¿æ•´å…‰ç·š/è‰²åŸŸæˆ–é è¿‘é¡é ­ã€‚';
        hintEl.className = 'hint bad';
      }

      // æ›´æ–°èˆ‡ç¹ªè£½ç‰©ä»¶
      updateItems(dt);
      drawItems(ctx);

      // ç•«ç«é¾ï¼ˆç”¨ centroid ä½œç‚ºé¾é ­ï¼‰
      const head = { x: centroid.x || W/2, y: centroid.y || H/2 };
      drawDragon(ctx, head, direction);

      // ç¢°æ’
      handleCollisions(head);

      // é£„å­—
      drawFloatTexts(dt);

      if (running && !gameOver) requestAnimationFrame(tick);
    }

    // ========= éŠæˆ²æ§åˆ¶ =========
    function startGameLoop() {
      if (running) return;
      running = true; gameOver = false;
      lastTime = performance.now();
      ensureItems();
      // å€’æ•¸è¨ˆæ™‚
      clearInterval(timerId);
      timeLeft = 60;
      timeEl.textContent = timeLeft;
      timerId = setInterval(() => {
        timeLeft--;
        timeEl.textContent = timeLeft;
        if (timeLeft <= 0) {
          clearInterval(timerId);
          running = false; gameOver = true;
          hintEl.textContent = `æ™‚é–“åˆ°ï¼ç¸½åˆ†ï¼š${score}`;
          hintEl.className = 'hint';
        }
      }, 1000);
      requestAnimationFrame(tick);
    }

    async function startAll() {
      try {
        await initCamera();
        // è‹¥éœ€è¦è¼‰å…¥èƒŒæ™¯åœ–ï¼Œé€™è£¡å¯è¨­å®š bgImg.src = '...';
        startGameLoop();
      } catch (err) {
        console.error(err);
        hintEl.textContent = 'ç›¸æ©Ÿç„¡æ³•å•Ÿå‹•ï¼Œè«‹ç¢ºèªæ¬Šé™èˆ‡ HTTPSã€‚';
      }
    }

    startBtn.addEventListener('click', startAll);
    resetBtn.addEventListener('click', () => {
      score = 0; combo = 0; scoreEl.textContent = score; comboEl.textContent = combo;
      items.length = 0; ensureItems();
      centroid = { x: W/2, y: H/2 };
      lastCentroid = { x: W/2, y: H/2 };
      direction = { x: 1, y: 0 };
      hintEl.textContent = 'é‡ç½®å®Œæˆï¼ŒæŒ‰ã€Œé–‹å§‹ã€é‡æ–°å•Ÿå‹•ç›¸æ©Ÿã€‚';
      running = false; gameOver = false;
      clearInterval(timerId);
    });

    // åˆå§‹é ­å°¾æ–¹å‘
    centroid = { x: W/2, y: H/2 };
    lastCentroid = { x: W/2 - 10, y: H/2 };
    direction = { x: 1, y: 0 };
  </script>
</body>
</html>
