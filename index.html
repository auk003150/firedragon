<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>WebAR Wrist + 竹龍跟隨 (MediaPipe)</title>

  <!-- MediaPipe Tasks Vision (Hand Landmarker) -->
  <script type="module">
    import { HandLandmarker, FilesetResolver } from
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    const ui = {
      btn: null,
      status: null,
      video: null,
      canvas: null,
      ctx: null
    };

    let handLandmarker;
    let running = false;
    let lastVideoTime = -1;

    // 竹龍狀態：用一串節點做「跟隨 + 慣性」
    const N = 30;                 // 節數
    const spacing = 10;           // 節點間距（像素）
    const nodes = Array.from({ length: N }, () => ({ x: 0, y: 0 }));
    let inited = false;

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    function resizeCanvasToVideo() {
      ui.canvas.width = ui.video.videoWidth;
      ui.canvas.height = ui.video.videoHeight;
      ui.canvas.style.width = ui.video.videoWidth + "px";
      ui.canvas.style.height = ui.video.videoHeight + "px";
    }

    function drawBambooDragon(headX, headY) {
      const ctx = ui.ctx;

      // 初始化節點到頭部位置
      if (!inited) {
        for (const p of nodes) { p.x = headX; p.y = headY; }
        inited = true;
      }

      // 頭節點追隨手腕（加一點平滑）
      nodes[0].x += (headX - nodes[0].x) * 0.35;
      nodes[0].y += (headY - nodes[0].y) * 0.35;

      // 其餘節點：保持固定距離，形成「蛇形/龍身」
      for (let i = 1; i < N; i++) {
        const prev = nodes[i - 1];
        const cur = nodes[i];
        const dx = cur.x - prev.x;
        const dy = cur.y - prev.y;
        const d = Math.hypot(dx, dy) || 1e-6;
        const targetX = prev.x + (dx / d) * spacing;
        const targetY = prev.y + (dy / d) * spacing;

        // 往目標位置拉回（平滑）
        cur.x += (targetX - cur.x) * 0.45;
        cur.y += (targetY - cur.y) * 0.45;
      }

      // 畫身體（綠色節狀）
      ctx.save();
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      // 身體主線
      ctx.beginPath();
      ctx.moveTo(nodes[0].x, nodes[0].y);
      for (let i = 1; i < N; i++) ctx.lineTo(nodes[i].x, nodes[i].y);
      ctx.strokeStyle = "rgba(30,160,60,0.9)";
      ctx.lineWidth = 10;
      ctx.stroke();

      // 節點（像竹節）
      for (let i = 0; i < N; i++) {
        const t = i / (N - 1);
        const r = 10 - 6 * t; // 越尾巴越細
        ctx.beginPath();
        ctx.arc(nodes[i].x, nodes[i].y, r, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(70, 200, 90, ${0.85 - 0.5 * t})`;
        ctx.fill();

        // 竹節環
        ctx.beginPath();
        ctx.arc(nodes[i].x, nodes[i].y, r * 0.85, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(10, 90, 30, ${0.35 - 0.2 * t})`;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // 簡單龍頭（兩個眼點）
      ctx.beginPath();
      ctx.arc(nodes[0].x - 6, nodes[0].y - 4, 2.2, 0, Math.PI * 2);
      ctx.arc(nodes[0].x + 6, nodes[0].y - 4, 2.2, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(20,40,20,0.9)";
      ctx.fill();

      ctx.restore();
    }

    async function setup() {
      ui.btn = document.getElementById("btn");
      ui.status = document.getElementById("status");
      ui.video = document.getElementById("video");
      ui.canvas = document.getElementById("canvas");
      ui.ctx = ui.canvas.getContext("2d");

      ui.status.textContent = "載入模型中…";

      // 官方建議：用 FilesetResolver 指向 wasm root，再 createFromOptions [page:1]
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );

      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        numHands: 1
      });

      ui.status.textContent = "就緒。";
      ui.btn.disabled = false;

      ui.btn.addEventListener("click", toggle);
    }

    async function startCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: "user",     // 前鏡頭；想用後鏡頭可改成 "environment"
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: false
      });
      ui.video.srcObject = stream;

      await ui.video.play();
      resizeCanvasToVideo();
      window.addEventListener("resize", resizeCanvasToVideo);
    }

    function stopCamera() {
      const stream = ui.video.srcObject;
      if (stream) {
        for (const t of stream.getTracks()) t.stop();
      }
      ui.video.srcObject = null;
    }

    async function toggle() {
      running = !running;
      ui.btn.textContent = running ? "Stop" : "Enable Webcam";

      if (running) {
        ui.status.textContent = "啟動相機…";
        await startCamera();
        ui.status.textContent = "偵測中（把手腕放到鏡頭前）";
        requestAnimationFrame(loop);
      } else {
        ui.status.textContent = "已停止。";
        stopCamera();
        ui.ctx.clearRect(0, 0, ui.canvas.width, ui.canvas.height);
        inited = false;
      }
    }

    function loop() {
      if (!running) return;

      // 避免同一幀重複算（官方範例也用 currentTime 來判斷）[page:1]
      if (ui.video.currentTime !== lastVideoTime) {
        lastVideoTime = ui.video.currentTime;

        const nowMs = performance.now();
        const res = handLandmarker.detectForVideo(ui.video, nowMs); // video 模式用 detectForVideo [page:1]

        ui.ctx.clearRect(0, 0, ui.canvas.width, ui.canvas.height);

        if (res?.landmarks?.length) {
          // landmark #0 = wrist（手腕），x/y 是 normalized [0,1]（官方說明）[page:1]
          const wrist = res.landmarks[0][0];
          const x = wrist.x * ui.canvas.width;
          const y = wrist.y * ui.canvas.height;

          drawBambooDragon(x, y);
        }
      }

      requestAnimationFrame(loop);
    }

    setup();
  </script>

  <style>
    html, body { margin: 0; height: 100%; background:#111; color:#eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", sans-serif; }
    #wrap { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    video, canvas { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; }
    video { transform: rotateY(180deg); }      /* 鏡像（自拍視角） */
    canvas { pointer-events: none; transform: rotateY(180deg); } /* 讓疊圖跟 video 同方向 */
    #hud {
      position: absolute; left: 12px; top: 12px; z-index: 10;
      background: rgba(0,0,0,0.45); padding: 10px 12px; border-radius: 10px;
      backdrop-filter: blur(6px);
      max-width: min(520px, calc(100vw - 24px));
    }
    button { font-size: 14px; padding: 8px 12px; border-radius: 10px; border: 0; cursor: pointer; }
    #status { margin-top: 8px; font-size: 13px; opacity: 0.9; line-height: 1.3; }
  </style>
</head>

<body>
  <div id="wrap">
    <div id="hud">
      <button id="btn" disabled>Enable Webcam</button>
      <div id="status">初始化中…</div>
    </div>

    <video id="video" playsinline muted></video>
    <canvas id="canvas"></canvas>
  </div>
</body>
</html>
