<!DOCTYPE html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Hiro Marker 偵測示例</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: #000; color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", Arial, sans-serif;
      overflow: hidden;
      touch-action: manipulation;
    }
    .wrap { position: relative; width: 100%; height: 100%; background: #000; }
    video#cam, canvas#game, img#bg {
      position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover;
    }
    canvas#game { pointer-events: none; }
    img#bg { pointer-events: none; mix-blend-mode: lighten; }
    .ui {
      position: absolute; left: 0; right: 0; top: 0;
      display: flex; justify-content: space-between; align-items: center;
      padding: 10px 12px; gap: 8px;
      background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0));
      z-index: 10; user-select: none;
      flex-wrap: wrap;
    }
    .btn {
      background: #e11d48; border: none; color: #fff;
      border-radius: 10px; padding: 10px 14px;
      font-weight: 700; letter-spacing: 0.5px;
      box-shadow: 0 4px 12px rgba(225,29,72,0.35);
      cursor: pointer;
    }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .hud {
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
      font-weight: 700; text-shadow: 0 2px 6px rgba(0,0,0,0.6);
    }
    .chip {
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 14px;
    }
    .hint {
      position: absolute; left: 0; right: 0; top: 50%;
      transform: translateY(-50%);
      text-align: center; padding: 0 16px;
      color: #ffd166; font-weight: 700;
      text-shadow: 0 2px 10px rgba(0,0,0,0.7);
      z-index: 5;
    }
    .hint.ok { color: #22c55e; }
    .hint.bad { color: #f97316; }
  </style>
</head>
<body>
  <div class="wrap">
    <video id="cam" autoplay playsinline muted></video>
    <img id="bg" alt="背景" src="image_1.png" />
    <canvas id="game"></canvas>

    <div class="ui">
      <button id="startBtn" class="btn">開始</button>
      <div class="hud">
        <div class="chip">分數：<span id="score">0</span></div>
        <div class="chip">時間：<span id="time">60</span>s</div>
      </div>
    </div>

    <div id="hint" class="hint">按「開始」並將 Hiro 標記放到鏡頭前。</div>
  </div>

  <!-- 嵌入極簡 js-aruco（Hiro marker 偵測） -->
  <script>
    (function(global){
      // --- 簡化版 CV 工具 ---
      var CV = {
        grayscale: function(imageSrc){
          var src=imageSrc.data, dst=new Uint8Array(imageSrc.width*imageSrc.height);
          for(var i=0,j=0;i<src.length;i+=4,++j){
            dst[j]=(src[i]*0.299 + src[i+1]*0.587 + src[i+2]*0.114)|0;
          }
          return {width:imageSrc.width,height:imageSrc.height,data:dst};
        },
        threshold: function(imageSrc, th){
          var src=imageSrc.data, dst=new Uint8Array(src.length);
          for(var i=0;i<src.length;++i) dst[i]=src[i]<=th?0:255;
          return {width:imageSrc.width,height:imageSrc.height,data:dst};
        },
        integralImage: function(imageSrc){
          var w=imageSrc.width,h=imageSrc.height, src=imageSrc.data, sum=new Int32Array(w*h);
          for(var y=0;y<h;++y){
            var row=y*w, rowsum=0;
            for(var x=0;x<w;++x){
              rowsum += src[row+x];
              sum[row+x] = rowsum + (y>0?sum[row-w+x]:0);
            }
          }
          return {width:w,height:h,data:sum};
        },
        adaptiveThreshold: function(imageSrc, S, T){
          var ii=this.integralImage(imageSrc), w=imageSrc.width, h=imageSrc.height, src=imageSrc.data, dst=new Uint8Array(src.length);
          var s2=S>>1;
          for(var y=0;y<h;++y){
            var y0=Math.max(y-s2,0), y1=Math.min(y+s2,h-1);
            for(var x=0;x<w;++x){
              var x0=Math.max(x-s2,0), x1=Math.min(x+s2,w-1);
              var count=(x1-x0+1)*(y1-y0+1);
              var sum=ii.data[y1*w+x1] - (y0>0?ii.data[(y0-1)*w+x1]:0) - (x0>0?ii.data[y1*w+x0-1]:0) + (x0>0&&y0>0?ii.data[(y0-1)*w+x0-1]:0);
              dst[y*w+x] = src[y*w+x]*count <= sum*(100-T)/100 ? 0:255;
            }
          }
          return {width:w,height:h,data:dst};
        },
        findContours: function(imageSrc){
          var labels=new Int32Array(imageSrc.data.length), label=1, comps=[];
          var w=imageSrc.width, h=imageSrc.height, data=imageSrc.data;
          function bfs(seed){
            var q=[seed], minx=w, miny=h, maxx=0, maxy=0, pts=[];
            labels[seed]=label;
            while(q.length){
              var idx=q.pop();
              var x=idx%w, y=idx/w|0;
              pts.push({x:x,y:y});
              if(x<minx)minx=x; if(x>maxx)maxx=x; if(y<miny)miny=y; if(y>maxy)maxy=y;
              var n=[idx-1,idx+1,idx-w,idx+w];
              for(var k=0;k<4;++k){
                var ni=n[k];
                if(ni<0||ni>=data.length) continue;
                if(labels[ni]||data[ni]) continue;
                labels[ni]=label; q.push(ni);
              }
            }
            comps.push({points:pts, minx,miny,maxx,maxy});
          }
          for(var i=0;i<data.length;++i){
            if(data[i]===0 && labels[i]===0){ bfs(i); label++; }
          }
          var contours=[];
          for(var c of comps){
            var rect=[
              {x:c.minx,y:c.miny},
              {x:c.maxx,y:c.miny},
              {x:c.maxx,y:c.maxy},
              {x:c.minx,y:c.maxy}
            ];
            contours.push(rect);
          }
          return contours;
        },
        perimeter: function(poly){
          var p=0;
          for(var i=0;i<poly.length;++i){
            var a=poly[i], b=poly[(i+1)%poly.length];
            var dx=a.x-b.x, dy=a.y-b.y;
            p+=Math.hypot(dx,dy);
          }
          return p;
        },
        approxPolyDP: function(curve, epsilon){
          // 本簡化實作假設輸入已近似矩形，直接回傳
          return curve;
        }
      };

      // --- ArUco 簡化 ---
      var AR = {};
      AR.Marker = function(id,corners){ this.id=id; this.corners=corners; };

      AR.Detector = function(){};
      AR.Detector.prototype.detect = function(imageData){
        // 1) 灰階 + 自適應閾值
        var gray = CV.grayscale(imageData);
        var bin = CV.adaptiveThreshold(gray, 15, 7);
        // 2) 找輪廓
        var contours = CV.findContours(bin);
        var markers=[];
        for(var c of contours){
          var peri = CV.perimeter(c);
          if(peri < 40) continue;
          var w = Math.hypot(c[0].x - c[1].x, c[0].y - c[1].y);
          var h = Math.hypot(c[1].x - c[2].x, c[1].y - c[2].y);
          var ratio = w/h;
          if(ratio<0.65 || ratio>1.45) continue;
          var approx = CV.approxPolyDP(c, 0.02*peri);
          if(approx.length !== 4) continue;
          // 簡化：凡符合矩形即視為 Hiro (id=0)
          markers.push(new AR.Marker(0, approx));
        }
        return markers;
      };

      global.CV = CV;
      global.AR = AR;
    })(window);
  </script>

  <script>
    // ===== 基本 DOM =====
    const video = document.getElementById('cam');
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: true });
    const startBtn = document.getElementById('startBtn');
    const scoreEl = document.getElementById('score');
    const timeEl = document.getElementById('time');
    const hintEl = document.getElementById('hint');

    let W = 0, H = 0, dpr = 1;
    function resize() {
      dpr = Math.min(window.devicePixelRatio || 1, 2);
      const rect = canvas.getBoundingClientRect();
      W = rect.width; H = rect.height;
      canvas.width = Math.round(W * dpr);
      canvas.height = Math.round(H * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // ===== 狀態 =====
    let running = false;
    let score = 0;
    let timeLeft = 60;
    let timerId = null;
    let centroid = { x: 0, y: 0 };
    let dragonImgReady = false;
    const dragonImg = new Image();
    dragonImg.src = 'image_2.png';
    dragonImg.onload = () => { dragonImgReady = true; };

    // ===== 相機 =====
    let currentStream = null;
    async function stopStream() {
      if (currentStream) {
        currentStream.getTracks().forEach(t => t.stop());
        currentStream = null;
      }
    }
    async function initCamera() {
      const constraints = { video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };
      await stopStream();
      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        video.srcObject = stream;
        await video.play();
        return true;
      } catch (err) {
        console.error(err);
        hintEl.textContent = '相機無法啟動，請確認權限與 HTTPS。';
        hintEl.className = 'hint bad';
        return false;
      }
    }

    // ===== Hiro 偵測 =====
    const workCanvas = document.createElement('canvas');
    const wctx = workCanvas.getContext('2d', { willReadFrequently: true });
    const detector = new AR.Detector();

    function markerArea(marker){
      const cs = marker.corners;
      let area = 0;
      for (let i=0;i<cs.length;i++){
        const c0 = cs[i], c1 = cs[(i+1)%cs.length];
        area += c0.x * c1.y - c1.x * c0.y;
      }
      return Math.abs(area) * 0.5;
    }

    function trackHiroMarker() {
      const vw = video.videoWidth|0, vh = video.videoHeight|0;
      if (vw === 0 || vh === 0) return null;

      const scale = 0.5;
      const w = Math.max(32, Math.round(vw * scale));
      const h = Math.max(32, Math.round(vh * scale));
      workCanvas.width = w; workCanvas.height = h;

      try { wctx.drawImage(video, 0, 0, w, h); }
      catch (e) { return null; }

      const imageData = wctx.getImageData(0, 0, w, h);
      const markers = detector.detect(imageData);
      if (!markers || markers.length === 0) return null;

      // 取最大面積的標記
      let best = markers[0];
      let bestArea = markerArea(best);
      for (let i=1;i<markers.length;i++){
        const a = markerArea(markers[i]);
        if (a > bestArea){ bestArea = a; best = markers[i]; }
      }
      const corners = best.corners;
      let cx = 0, cy = 0;
      for (const c of corners){ cx += c.x; cy += c.y; }
      cx /= corners.length; cy /= corners.length;

      const canvasX = (cx / w) * W;
      const canvasY = (cy / h) * H;
      return { x: canvasX, y: canvasY, area: bestArea };
    }

    // ===== 遊戲物件（簡化：只有龍頭與分數計時）=====
    function drawDragon(head) {
      if (!dragonImgReady) return;
      const imgW = 100, imgH = 100;
      ctx.save();
      ctx.translate(head.x, head.y);
      ctx.drawImage(dragonImg, -imgW*0.5, -imgH*0.5, imgW, imgH);
      ctx.restore();
    }

    // ===== 主迴圈 =====
    let lastTime = performance.now();
    function tick(now) {
      if (!running) return;
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;

      ctx.clearRect(0, 0, W, H);

      const m = trackHiroMarker();
      if (m) {
        centroid.x = centroid.x + (m.x - centroid.x) * 0.35;
        centroid.y = centroid.y + (m.y - centroid.y) * 0.35;
        hintEl.textContent = '已偵測到 Hiro 標記，保持在鏡頭前。';
        hintEl.className = 'hint ok';
      } else {
        hintEl.textContent = '未偵測到 Hiro 標記，請將標記清晰置於鏡頭前並確保光線充足。';
        hintEl.className = 'hint bad';
      }

      drawDragon({ x: centroid.x || W/2, y: centroid.y || H/2 });

      requestAnimationFrame(tick);
    }

    // ===== 控制 =====
    function startGame() {
      if (running) return;
      running = true;
      score = 0;
      timeLeft = 60;
      scoreEl.textContent = score;
      timeEl.textContent = timeLeft;

      clearInterval(timerId);
      timerId = setInterval(() => {
        timeLeft--;
        timeEl.textContent = timeLeft;
        if (timeLeft <= 0) {
          clearInterval(timerId);
          running = false;
          hintEl.textContent = `時間到！總分：${score}`;
          hintEl.className = 'hint';
        }
      }, 1000);

      lastTime = performance.now();
      requestAnimationFrame(tick);
    }

    startBtn.addEventListener('click', async () => {
      startBtn.disabled = true;
      const ok = await initCamera();
      if (ok) {
        resize();
        startGame();
      } else {
        startBtn.disabled = false;
      }
    });

    // 初始居中
    centroid = { x: W/2, y: H/2 };
  </script>
</body>
</html>
