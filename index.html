<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Hiro Marker AR Demo + ç¢°æ’èˆ‡åˆ†æ•¸ï¼ˆå¯è¦‹ç‰ˆï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <!-- AR.js for A-Frame -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; }
    body { font-family: system-ui, -apple-system, "Helvetica Neue", Arial, sans-serif; }
    .overlay {
      position: fixed;
      top: 0; left: 0; right: 0;
      display: flex; justify-content: space-between; align-items: center;
      padding: 12px 16px;
      background: linear-gradient(180deg, rgba(0,0,0,0.65), rgba(0,0,0,0));
      color: #fff; z-index: 20; pointer-events: none;
      font-size: 14px;
    }
    .hint {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      padding: 10px 14px;
      background: linear-gradient(0deg, rgba(0,0,0,0.7), rgba(0,0,0,0));
      color: #fff; z-index: 20; text-align: center;
      font-size: 13px; pointer-events: none;
    }
    .badge {
      background: rgba(255,255,255,0.12);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      pointer-events: auto;
    }
    .link { color: #9ad6ff; text-decoration: underline; pointer-events: auto; }
    .score { pointer-events: none; font-weight: 600; }

    /* ç›®æ¨™å®¹å™¨ï¼šåœ¨æœ€ä¸Šå±¤ HUD ä¹‹ä¸‹ä½†é«˜æ–¼ <canvas>ï¼Œç¢ºä¿å¯è¦‹ */
    .targets-layer {
      position: fixed;
      inset: 0;
      z-index: 10;
      pointer-events: none; /* ä¸é˜»æ“‹ç›¸æ©Ÿäº’å‹• */
    }
    .target {
      position: absolute;
      transform: translate(-50%, -50%);
      font-size: 28px; /* å›ºå®šé¡¯ç¤ºå¤§å° */
      line-height: 1;
      user-select: none;
      filter: drop-shadow(0 1px 0 rgba(0,0,0,0.3))
              drop-shadow(0 2px 4px rgba(0,0,0,0.25));
      transition: transform 0.08s ease-out;
    }
    .target.first { color: #00E676; }
    .target.second { color: #FF5252; }

    @media (max-width: 640px) {
      .overlay { font-size: 13px; padding: 10px 12px; }
      .hint { font-size: 12px; padding: 8px 12px; }
      .target { font-size: 24px; }
    }
  </style>
</head>
<body>
  <div class="overlay">
    <div class="badge">Hiro Marker AR</div>
    <div class="score" id="score">åˆ†æ•¸ï¼š0</div>
  </div>

  <div class="targets-layer" id="targetsLayer"></div>

  <div class="hint">
    å°‡ Hiro æ¨™è¨˜ç½®æ–¼é¡é ­å‰æ–¹ï¼Œ3D ç‰©ä»¶æœƒå‡ºç¾åœ¨æ¨™è¨˜ä¸Šã€‚<br/>
    æ²’æœ‰æ¨™è¨˜ï¼Ÿå¯åˆ—å°ï¼š<a class="link" href="https://raw.githubusercontent.com/AR-js-org/AR.js/master/aframe/examples/marker-training/examples/pattern-files/pattern-hiro.png" target="_blank" rel="noopener">ä¸‹è¼‰ Hiro åœ–</a><br/>
    æç¤ºï¼šç§»å‹•æ¨™è¨˜å»ç¢°è§¸è¢å¹•ä¸­çš„å­—å…ƒä¾†åŠ æ¸›åˆ†ï¼
  </div>

  <a-scene
    vr-mode-ui="enabled: false"
    embedded
    renderer="logarithmicDepthBuffer: true; antialias: true;"
    arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono; maxDetectionRate: 30;"
  >
    <!-- å…‰æº -->
    <a-entity light="type: ambient; color: #cccccc"></a-entity>
    <a-entity light="type: directional; color: #ffffff; intensity: 0.8" position="1 1 0.5"></a-entity>

    <!-- Hiro æ¨™è¨˜ï¼ˆç©å®¶ï¼‰ -->
    <a-marker preset="hiro" id="marker">
      <a-box id="player"
             position="0 0.5 0"
             depth="1" height="1" width="1"
             color="#4FC3F7"
             animation="property: rotation; to: 0 360 0; loop: true; dur: 4000; easing: linear">
      </a-box>
      <a-cylinder position="0 0 0" radius="0.35" height="0.1" color="#FFC107"></a-cylinder>
    </a-marker>

    <!-- ç›¸æ©Ÿ -->
    <a-entity camera id="camera"></a-entity>

    <!-- ç‚ºæ¯å€‹ç•«é¢ç›®æ¨™å»ºç«‹å°æ‡‰çš„ 3D ç¢°æ’é»ï¼ˆä¸å¯è¦‹ï¼‰ -->
    <a-entity id="collidersRoot"></a-entity>

    <script>
      const FIRST_SET = ['ç¦', 'æ˜¥', 'è²¡', 'å®‰', 'æ—º', 'å‰', 'ç¥¥', 'è³€', 'é¾', 'å¹´'];
      const SECOND_SET = ['âš½', 'ğŸ”', 'ğŸ§', 'ğŸ§Š', 'ğŸ§¼', 'ğŸº', 'ğŸ’¡', 'ğŸ“', 'ğŸ§½', 'ğŸ§¯'];

      const COUNT_PER_SET = 10;
      const SPEED_MIN = 60;
      const SPEED_MAX = 160;

      // 3D ç¢°æ’ç”¨åƒæ•¸
      const PLANE_DISTANCE = 2;     // ç›¸æ©Ÿå‰æ–¹ 2 å…¬å°º
      const COLLIDE_RADIUS = 0.75;  // èˆ‡ç©å®¶æ–¹å¡Šçš„ç¢°æ’åŠå¾‘
      const SCORE_HIT_FIRST = 15;
      const SCORE_HIT_SECOND = -5;
      const HIT_COOLDOWN_MS = 600;

      const scene = document.querySelector('a-scene');
      const cameraEl = document.getElementById('camera');
      const markerEl = document.getElementById('marker');
      const playerEl = document.getElementById('player');
      const collidersRoot = document.getElementById('collidersRoot');

      const targetsLayer = document.getElementById('targetsLayer');
      const scoreEl = document.getElementById('score');

      let score = 0;
      function setScore(v){ score=v; scoreEl.textContent = `åˆ†æ•¸ï¼š${score}`; }

      // å·¥å…·ï¼šè¢å¹•åº§æ¨™ -> ç›¸æ©Ÿå‰æ–¹å›ºå®šè·é›¢çš„ä¸–ç•Œåº§æ¨™
      function screenToWorldAtDistance(sx, sy, dist) {
        const threeCam = cameraEl.getObject3D('camera');
        if (!threeCam) return null;
        const ndc = new THREE.Vector3(
          (sx / window.innerWidth) * 2 - 1,
          -(sy / window.innerHeight) * 2 + 1,
          0.5
        );
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(ndc, threeCam);
        const origin = raycaster.ray.origin.clone();
        const dir = raycaster.ray.direction.clone().normalize();
        return origin.add(dir.multiplyScalar(dist));
      }

      // å»ºç«‹ä¸€å€‹ç›®æ¨™ï¼ˆç•«é¢å…ƒç´  + å°æ‡‰çš„ 3D ç¢°æ’é»ï¼‰
      function createTarget(char, type) {
        // 1) ç•«é¢å…ƒç´ 
        const span = document.createElement('span');
        span.className = `target ${type === 'first' ? 'first' : 'second'}`;
        span.textContent = char;
        targetsLayer.appendChild(span);

        // éš¨æ©Ÿåˆå§‹ä½ç½®èˆ‡é€Ÿåº¦
        const margin = 28;
        const st = {
          type,
          sx: Math.random() * (window.innerWidth - margin*2) + margin,
          sy: Math.random() * (window.innerHeight - margin*2) + margin,
          vx: (Math.random()*2-1) * (SPEED_MIN + Math.random()*(SPEED_MAX-SPEED_MIN)),
          vy: (Math.random()*2-1) * (SPEED_MIN + Math.random()*(SPEED_MAX-SPEED_MIN)),
          lastHitAt: 0
        };
        span.__state = st;

        // 2) å°æ‡‰ 3D ç¢°æ’é»ï¼ˆä¸å¯è¦‹å°çƒï¼‰
        const col = document.createElement('a-entity');
        col.setAttribute('geometry', 'primitive: sphere; radius: 0.01');
        col.setAttribute('material', 'visible: false; color: #fff; opacity: 0');
        collidersRoot.appendChild(col);
        span.__collider = col;

        // åˆæ¬¡å®šä½ DOM
        span.style.left = `${st.sx}px`;
        span.style.top = `${st.sy}px`;

        return span;
      }

      const targets = [];
      function spawnAllTargets() {
        for (let i=0; i<COUNT_PER_SET; i++) {
          targets.push(createTarget(FIRST_SET[i % FIRST_SET.length], 'first'));
        }
        for (let i=0; i<COUNT_PER_SET; i++) {
          targets.push(createTarget(SECOND_SET[i % SECOND_SET.length], 'second'));
        }
      }

      function hitFeedback(span) {
        span.style.transform = 'translate(-50%, -50%) scale(1.3)';
        setTimeout(() => {
          span.style.transform = 'translate(-50%, -50%) scale(1)';
        }, 120);
      }

      let lastT = performance.now();
      function loop() {
        const now = performance.now();
        const dt = (now - lastT) / 1000;
        lastT = now;

        const margin = 20;
        const minX = margin, maxX = window.innerWidth - margin;
        const minY = margin, maxY = window.innerHeight - margin;

        // æ›´æ–°æ¯å€‹ç›®æ¨™ä½ç½®ï¼ˆè¢å¹• 2Dï¼‰èˆ‡ 3D ç¢°æ’é»
        for (const span of targets) {
          const st = span.__state;
          if (!st) continue;

          st.sx += st.vx * dt;
          st.sy += st.vy * dt;

          // é‚Šç•Œåå½ˆ
          if (st.sx < minX) { st.sx = minX; st.vx = Math.abs(st.vx); }
          if (st.sx > maxX) { st.sx = maxX; st.vx = -Math.abs(st.vx); }
          if (st.sy < minY) { st.sy = minY; st.vy = Math.abs(st.vy); }
          if (st.sy > maxY) { st.sy = maxY; st.vy = -Math.abs(st.vy); }

          // DOM ä½ç½®
          span.style.left = `${st.sx}px`;
          span.style.top = `${st.sy}px`;

          // æ›´æ–° 3D ç¢°æ’é»ä½ç½®
          const world = screenToWorldAtDistance(st.sx, st.sy, PLANE_DISTANCE);
          if (world) {
            span.__collider.object3D.position.copy(world);
          }
        }

        // ç©å®¶ä¸–ç•Œä½ç½®
        const playerWorld = new THREE.Vector3();
        playerEl.object3D.getWorldPosition(playerWorld);

        // ç¢°æ’èˆ‡è¨ˆåˆ†
        for (const span of targets) {
          const st = span.__state;
          if (!st) continue;
          const col = span.__collider;
          const pos = new THREE.Vector3();
          col.object3D.getWorldPosition(pos);
          const dist = playerWorld.distanceTo(pos);
          if (dist <= COLLIDE_RADIUS) {
            if (now - st.lastHitAt > HIT_COOLDOWN_MS) {
              st.lastHitAt = now;
              setScore(score + (st.type === 'first' ? SCORE_HIT_FIRST : SCORE_HIT_SECOND));
              hitFeedback(span);
            }
          }
        }

        requestAnimationFrame(loop);
      }

      function start() {
        spawnAllTargets();
        lastT = performance.now();
        requestAnimationFrame(loop);
      }

      if (document.readyState === 'complete') {
        if (scene.hasLoaded) start();
        else scene.addEventListener('loaded', start);
      } else {
        window.addEventListener('load', () => {
          if (scene.hasLoaded) start();
          else scene.addEventListener('loaded', start);
        });
      }

      // è¢å¹•æ—‹è½‰æˆ–å°ºå¯¸æ”¹è®Šï¼Œç¶­æŒç›®æ¨™åœ¨å¯è¦–ç¯„åœ
      window.addEventListener('resize', () => {
        const margin = 24;
        for (const span of targets) {
          const st = span.__state;
          st.sx = Math.min(Math.max(st.sx, margin), window.innerWidth - margin);
          st.sy = Math.min(Math.max(st.sy, margin), window.innerHeight - margin);
          span.style.left = `${st.sx}px`;
          span.style.top = `${st.sy}px`;
        }
      });
    </script>
  </a-scene>
</body>
</html>
